class OverpassStatementBase {
}
class ComposableOverpassStatementBase extends OverpassStatementBase {
    union(statement) {
        return new OverpassUnionStatement(this, statement);
    }
    difference(statement) {
        return new OverpassDifferenceStatement(this, statement);
    }
    toSet(set) {
        return new OverpassSetStatement(this, set);
    }
}
class ChainableOverpassStatementBase extends ComposableOverpassStatementBase {
    constructor(target, chain) {
        super();
        this.target = target;
        this.chain = chain;
    }
    and(statement) {
        const actualStatement = typeof statement == "function" ? statement(this.chain) : statement;
        return new AndChainableOverpassStatementImp(this.target, this.chain, [this, actualStatement]);
    }
    compile(u) {
        const target = this.target.compile(u);
        const parts = this.compileChainable(u);
        return u.template `${target} ${u.join(parts, "\n\t")}`;
    }
}
class AndChainableOverpassStatementImp extends ChainableOverpassStatementBase {
    constructor(target, chain, chained) {
        super(target, chain);
        this.chained = chained
            .map((statement) => statement instanceof AndChainableOverpassStatementImp ? statement.chained : [statement])
            .flat();
    }
    compileChainable(u) {
        return this.chained.map((statement) => statement.compileChainable(u)).flat();
    }
}
class OverpassDifferenceStatement extends ComposableOverpassStatementBase {
    constructor(statement1, statement2) {
        super();
        this.statement1 = statement1;
        this.statement2 = statement2;
    }
    compile(utils) {
        const statement1 = this.statement1.compile(utils);
        const statement2 = this.statement2.compile(utils);
        return utils.template `(${statement1}; - ${statement2};)`;
    }
}
class OverpassSetStatement extends ComposableOverpassStatementBase {
    constructor(statement1, setName) {
        super();
        this.statement1 = statement1;
        this.setName = setName;
    }
    compile(utils) {
        const statement1 = this.statement1.compile(utils);
        return utils.template `${statement1}->.${utils.set(this.setName)}`;
    }
}
class OverpassUnionStatement extends ComposableOverpassStatementBase {
    constructor(statement1, statement2) {
        super();
        this.statement1 = statement1;
        this.statement2 = statement2;
    }
    compile(utils) {
        const statement1 = this.statement1.compile(utils);
        const statement2 = this.statement2.compile(utils);
        return utils.template `(${statement1}; ${statement2};)`;
    }
}

class OverpassAreaStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, set) {
        super(target, chain);
        this.set = set;
    }
    compileChainable(u) {
        if (this.set != null)
            return [u.template `(area.${u.set(this.set)})`];
        else
            return [u.raw("(area)")];
    }
}
class OverpassPivotStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, set) {
        super(target, chain);
        this.set = set;
    }
    compileChainable(u) {
        if (this.set != null)
            return [u.template `(pivot.${u.set(this.set)})`];
        else
            return [u.raw("(pivot)")];
    }
}

class OverpassAroundCenterStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, radius, center) {
        super(target, chain);
        this.radius = radius;
        this.center = center;
    }
    compileChainable(u) {
        const radius = u.number(this.radius);
        const { lat, lon } = u.geoPos(this.center);
        return [u.template `(around: ${radius}, ${lat}, ${lon})`];
    }
}
class OverpassAroundSetStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, radius, set) {
        super(target, chain);
        this.radius = radius;
        this.set = set;
    }
    compileChainable(u) {
        const radius = u.number(this.radius);
        if (this.set != null)
            return [u.template `(around.${u.set(this.set)}: ${radius})`];
        else
            return [u.template `(around: ${radius})`];
    }
}
class OverpassAroundLineStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, radius, line) {
        super(target, chain);
        this.radius = radius;
        this.line = line;
    }
    compileChainable(u) {
        const radius = u.number(this.radius);
        const line = this.line.map((geoPos) => {
            const { lat, lon } = u.geoPos(geoPos);
            return u.template `${lat}, ${lon}`;
        });
        return [u.template `(around: ${radius}, ${u.join(line, ", ")})`];
    }
}

class OverpassBBoxStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, bbox) {
        super(target, chain);
        this.bbox = bbox;
    }
    compileChainable(u) {
        const [south, west, north, east] = u.bbox(this.bbox);
        return [u.template `(${south}, ${west}, ${north}, ${east})`];
    }
}

class OverpassForEachStatement extends OverpassStatementBase {
    constructor(body, set, item) {
        super();
        this.body = body;
        this.set = set;
        this.item = item;
    }
    compileDefinition(u) {
        if (this.set != null && this.item != null) {
            return u.template `foreach.${u.set(this.set)}->.${u.set(this.item)}`;
        }
        else if (this.set != null) {
            return u.template `foreach.${u.set(this.set)}`;
        }
        else if (this.item != null) {
            return u.template `foreach->.${u.set(this.item)}`;
        }
        else {
            return u.raw("foreach");
        }
    }
    static Tabulate(raw) {
        return raw
            .split("\n")
            .map((line) => `\t${line}`)
            .join("\n");
    }
    compileBlock(u) {
        const bodyStm = this.body({ name: this.set });
        const array = bodyStm instanceof Array ? bodyStm : [bodyStm];
        const statements = u.join(array.map((stm) => u.template `${stm.compile(u)};`), "\n");
        return statements.transform(OverpassForEachStatement.Tabulate);
    }
    compile(u) {
        const foreach = this.compileDefinition(u);
        return u.template `${foreach} {${u.nl}${this.compileBlock(u)}${u.nl}}`;
    }
}

class OverpassByIdStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, id) {
        super(target, chain);
        this.id = id;
    }
    compileChainable(u) {
        if (this.id instanceof Array) {
            const ids = this.id.map((id) => u.number(id));
            return [u.template `(id:${u.join(ids, ", ")})`];
        }
        else {
            return [u.template `(${u.number(this.id)})`];
        }
    }
}

class OverpassIfFilterStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, predicate) {
        super(target, chain);
        this.predicate = predicate;
    }
    compileChainable(u) {
        return [u.template `(if: ${this.predicate.compile(u)})`];
    }
}

class OverpassOutStatement extends OverpassStatementBase {
    constructor(options) {
        super();
        this.options = options;
    }
    compile(u) {
        const { verbosity, geoInfo, boundingBox, sortOrder, limit, targetSet } = this.options;
        const params = [];
        if (verbosity != null) {
            params.push(u.verbosity(verbosity));
        }
        if (geoInfo != null) {
            params.push(u.geoInfo(geoInfo));
        }
        if (boundingBox != null) {
            const [s, w, n, e] = u.bbox(boundingBox);
            params.push(u.template `(${s},${w},${n},${e})`);
        }
        if (sortOrder != null) {
            params.push(u.sortOrder(sortOrder));
        }
        if (limit != null) {
            params.push(u.number(limit));
        }
        const target = targetSet == null ? u.raw("_") : u.set(targetSet);
        return u.template `.${target} out ${u.join(params, " ")}`;
    }
}

class OverpassInsidePolygonStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, polygon) {
        super(target, chain);
        this.polygon = polygon;
    }
    compileChainable(u) {
        const polygon = this.polygon.map((geoPos) => {
            const { lat, lon } = u.geoPos(geoPos);
            return u.template `${lat} ${lon}`;
        });
        return [u.template `(poly: "${u.join(polygon, " ")}")`];
    }
}

class OverpassByTagsStatement extends ChainableOverpassStatementBase {
    constructor(target, chain, tags) {
        super(target, chain);
        this.tags = tags;
    }
    compileChainable(u) {
        return this.tags.map((tag) => tag.compile(u));
    }
}

function removeLastSemicolon(statement) {
    statement = statement.trim();
    if (statement.endsWith(";")) {
        return statement.slice(0, -1).trim();
    }
    else {
        return statement;
    }
}
class OverpassRawStatement extends OverpassStatementBase {
    constructor(compileFn) {
        super();
        this.compileFn = compileFn;
    }
    compile(u) {
        return this.compileFn(u).asString().transform(removeLastSemicolon);
    }
}
class OverpassComposableRawStatement extends ComposableOverpassStatementBase {
    constructor(compileFn) {
        super();
        this.compileFn = compileFn;
    }
    compile(u) {
        return this.compileFn(u).asString().transform(removeLastSemicolon);
    }
}

var StringQuoteType;
(function (StringQuoteType) {
    StringQuoteType["Single"] = "'";
    StringQuoteType["Double"] = "\"";
})(StringQuoteType || (StringQuoteType = {}));

/**
 * Node = 0x0001
 * Way = 0x0010
 * Relation = 0x0100
 * --------
 * NodeWay = 0x0011 ( Node | Way )
 * NodeRelation = 0x0101 ( Node | Relation )
 * WayRelation = 0x0110 ( Way | Relation )
 * NodeWayRelation = 0x0111 ( Node | Way | Relation )
 */
var OverpassQueryTarget;
(function (OverpassQueryTarget) {
    OverpassQueryTarget[OverpassQueryTarget["Node"] = 1] = "Node";
    OverpassQueryTarget[OverpassQueryTarget["Way"] = 2] = "Way";
    /** Node | Way */
    OverpassQueryTarget[OverpassQueryTarget["NodeWay"] = 3] = "NodeWay";
    OverpassQueryTarget[OverpassQueryTarget["Relation"] = 4] = "Relation";
    /** Node | Relation */
    OverpassQueryTarget[OverpassQueryTarget["NodeRelation"] = 5] = "NodeRelation";
    /** Way | Relation */
    OverpassQueryTarget[OverpassQueryTarget["WayRelation"] = 6] = "WayRelation";
    /** Node | Way | Relation */
    OverpassQueryTarget[OverpassQueryTarget["NodeWayRelation"] = 7] = "NodeWayRelation";
    OverpassQueryTarget[OverpassQueryTarget["Area"] = 8] = "Area";
    OverpassQueryTarget[OverpassQueryTarget["Derived"] = 9] = "Derived";
})(OverpassQueryTarget || (OverpassQueryTarget = {}));
/** Recurse standalone statements take an input set, and produce a result set */
var OverpassRecurseStmType;
(function (OverpassRecurseStmType) {
    /**
     * All ways that have a node which appears in the input set
     * All relations that have a node or way which appears in the input set
     * All relations that have a way which appears in the result set
     */
    OverpassRecurseStmType[OverpassRecurseStmType["Up"] = 0] = "Up";
    /**
     * All nodes that are part of a way which appears in the input set
     * All nodes and ways that are members of a relation which appears in the input set
     * All nodes that are part of a way which appears in the result set
     */
    OverpassRecurseStmType[OverpassRecurseStmType["Down"] = 1] = "Down";
    /**
     * Additional to {@link OverpassRecurseStmType.Up}, it continues to follow backlinks onto the found relations
     * until it contains all relations that point to an object in the input or result set.
     */
    OverpassRecurseStmType[OverpassRecurseStmType["UpRelations"] = 2] = "UpRelations";
    /**
     * Additional to {@link OverpassRecurseStmType.Down}, it continues to follow the membership links including nodes in ways
     * until for every object in its input or result set all the members of that object are in the result set as well.
     */
    OverpassRecurseStmType[OverpassRecurseStmType["DownRelations"] = 3] = "DownRelations";
})(OverpassRecurseStmType || (OverpassRecurseStmType = {}));
var OverpassOutputVerbosity;
(function (OverpassOutputVerbosity) {
    /** Print only the ids of the elements in the set. */
    OverpassOutputVerbosity[OverpassOutputVerbosity["Ids"] = 0] = "Ids";
    /**
     * Print the minimum information necessary for geometry:
     *  - nodes: id and coordinates
     *  - ways: id and the ids of its member nodes
     *  - relations: id of the relation, and the id, type, and role of all of its members.
     */
    OverpassOutputVerbosity[OverpassOutputVerbosity["Geometry"] = 1] = "Geometry";
    /**
     * Print all information necessary to use the data.
     * These are also tags for all elements and the roles for relation members.
     */
    OverpassOutputVerbosity[OverpassOutputVerbosity["Body"] = 2] = "Body";
    /** Print only ids and tags for each element and not coordinates or members. */
    OverpassOutputVerbosity[OverpassOutputVerbosity["Tags"] = 3] = "Tags";
    /**
     * Print everything known about the elements.
     * Includes everything output by body for each OSM element, as well as the version,
     * changeset id, timestamp, and the user data of the user that last touched the object.
     * Derived elements' metadata attributes are also missing for derived elements.
     */
    OverpassOutputVerbosity[OverpassOutputVerbosity["Metadata"] = 4] = "Metadata";
})(OverpassOutputVerbosity || (OverpassOutputVerbosity = {}));
var OverpassOutputGeoInfo;
(function (OverpassOutputGeoInfo) {
    /**
     * Add the full geometry to each object.
     * This adds coordinates to each node, to each node member of a way or relation,
     * and it adds a sequence of "nd" members with coordinates to all relations.
     */
    OverpassOutputGeoInfo[OverpassOutputGeoInfo["Geometry"] = 0] = "Geometry";
    /**
     * Adds only the bounding box of each element to the element.
     * For nodes this is equivalent to geom. For ways it is the enclosing bounding box of all nodes.
     * For relations it is the enclosing bounding box of all node and way members, relations as members have no effect.
     */
    OverpassOutputGeoInfo[OverpassOutputGeoInfo["BoundingBox"] = 1] = "BoundingBox";
    /**
     * This adds only the centre of the above mentioned bounding box to ways and relations.
     * Note: The center point is not guaranteed to lie inside the polygon (example).
     */
    OverpassOutputGeoInfo[OverpassOutputGeoInfo["Center"] = 2] = "Center";
})(OverpassOutputGeoInfo || (OverpassOutputGeoInfo = {}));
var OverpassSortOrder;
(function (OverpassSortOrder) {
    /** Sort by object id */
    OverpassSortOrder[OverpassSortOrder["Ascending"] = 0] = "Ascending";
    /**
     * Sort by quadtile index;
     * This is roughly geographical and significantly faster than order by ids
     * (derived elements generated by make or convert statements without any geometry will be grouped separately,
     * only sorted by id).
     */
    OverpassSortOrder[OverpassSortOrder["QuadtileIndex"] = 1] = "QuadtileIndex";
})(OverpassSortOrder || (OverpassSortOrder = {}));

var OverpassErrorType;
(function (OverpassErrorType) {
    OverpassErrorType[OverpassErrorType["QueryTimeout"] = 0] = "QueryTimeout";
    OverpassErrorType[OverpassErrorType["NetworkError"] = 1] = "NetworkError";
    OverpassErrorType[OverpassErrorType["TooManyRequests"] = 2] = "TooManyRequests";
    OverpassErrorType[OverpassErrorType["DuplicateQuery"] = 3] = "DuplicateQuery";
    OverpassErrorType[OverpassErrorType["QueryError"] = 4] = "QueryError";
    OverpassErrorType[OverpassErrorType["ServerError"] = 5] = "ServerError";
    OverpassErrorType[OverpassErrorType["UnknownError"] = 6] = "UnknownError";
    OverpassErrorType[OverpassErrorType["MemoryExhaustionError"] = 7] = "MemoryExhaustionError";
    OverpassErrorType[OverpassErrorType["NoAtticData"] = 8] = "NoAtticData";
    OverpassErrorType[OverpassErrorType["ParameterError"] = 9] = "ParameterError";
})(OverpassErrorType || (OverpassErrorType = {}));
class OverpassError extends Error {
    constructor(type, message, options) {
        const typeMessage = `OverpassError: ${OverpassErrorType[type]}`;
        super(message != null ? `[${typeMessage}] ${message}` : typeMessage, options);
        this.type = type;
    }
}
class OverpassParameterError extends OverpassError {
    constructor(message, options) {
        super(OverpassErrorType.ParameterError, message, options);
    }
}
class OverpassApiError extends OverpassError {
    constructor(type, httpCode, url, message, options) {
        super(type, `${url.toString()}[${httpCode}] ${message}`, options);
        this.httpCode = httpCode;
        this.url = url;
    }
}
class OverpassQueryError extends OverpassApiError {
    constructor(type, httpCode, url, query, message, options) {
        super(type, httpCode, url, `${message}\n${query}`, options);
        this.query = query;
    }
}
class OverpassRemarkError extends OverpassError {
    constructor(type, query, remarks, options) {
        super(type, [...remarks, query].join("\n"), options);
        this.query = query;
        this.remarks = remarks;
    }
}

var ParamType;
(function (ParamType) {
    ParamType[ParamType["Number"] = 0] = "Number";
    ParamType[ParamType["String"] = 1] = "String";
    ParamType[ParamType["RegExp"] = 2] = "RegExp";
    ParamType[ParamType["BoundingBox"] = 3] = "BoundingBox";
    ParamType[ParamType["GeoPos"] = 4] = "GeoPos";
    ParamType[ParamType["Date"] = 5] = "Date";
    ParamType[ParamType["Boolean"] = 6] = "Boolean";
    ParamType[ParamType["Target"] = 7] = "Target";
    ParamType[ParamType["Verbosity"] = 8] = "Verbosity";
    ParamType[ParamType["GeoInfo"] = 9] = "GeoInfo";
    ParamType[ParamType["SortOrder"] = 10] = "SortOrder";
    ParamType[ParamType["RecurseStm"] = 11] = "RecurseStm";
})(ParamType || (ParamType = {}));
class ParamItem {
    constructor(index, type) {
        this.index = index;
        this.type = type;
    }
    isType(type) {
        return type == this.type;
    }
}

var OverpasComparissonOperator;
(function (OverpasComparissonOperator) {
    OverpasComparissonOperator[OverpasComparissonOperator["Lower"] = 0] = "Lower";
    OverpasComparissonOperator[OverpasComparissonOperator["LowerOrEquals"] = 1] = "LowerOrEquals";
    OverpasComparissonOperator[OverpasComparissonOperator["GreaterOrEquals"] = 2] = "GreaterOrEquals";
    OverpasComparissonOperator[OverpasComparissonOperator["Greater"] = 3] = "Greater";
})(OverpasComparissonOperator || (OverpasComparissonOperator = {}));

var OverpassArithmeticOperator;
(function (OverpassArithmeticOperator) {
    OverpassArithmeticOperator[OverpassArithmeticOperator["Add"] = 0] = "Add";
    OverpassArithmeticOperator[OverpassArithmeticOperator["Sub"] = 1] = "Sub";
    OverpassArithmeticOperator[OverpassArithmeticOperator["Mult"] = 2] = "Mult";
    OverpassArithmeticOperator[OverpassArithmeticOperator["Divide"] = 3] = "Divide";
})(OverpassArithmeticOperator || (OverpassArithmeticOperator = {}));

var OverpassFormat;
(function (OverpassFormat) {
    OverpassFormat[OverpassFormat["XML"] = 0] = "XML";
    /** The output will be parsed */
    OverpassFormat[OverpassFormat["JSON"] = 1] = "JSON";
    /** The output will not be parsed */
    OverpassFormat[OverpassFormat["JSONText"] = 2] = "JSONText";
    /** Additional configuration needed @see OverpassCSVSettings.csvSettings */
    OverpassFormat[OverpassFormat["CSV"] = 3] = "CSV";
    /** HTML document with list containing maps */
    OverpassFormat[OverpassFormat["Custom"] = 4] = "Custom";
    OverpassFormat[OverpassFormat["Popup"] = 5] = "Popup";
})(OverpassFormat || (OverpassFormat = {}));
var CSVField;
(function (CSVField) {
    /* OSM Object ID */
    CSVField[CSVField["Id"] = 0] = "Id";
    /* OSM Object type: node, way, relation */
    CSVField[CSVField["Type"] = 1] = "Type";
    /* OSM Object as numeric value */
    CSVField[CSVField["OType"] = 2] = "OType";
    /* Latitude (available for nodes, or in out center mode) */
    CSVField[CSVField["Latitude"] = 3] = "Latitude";
    /* Longitude (available for nodes, or in out center mode) */
    CSVField[CSVField["Longitude"] = 4] = "Longitude";
    /**
     * The following meta information fields are only available if out meta;
     * Is used to output OSM elements.
     */
    /* OSM object's version number */
    CSVField[CSVField["Version"] = 5] = "Version";
    /* Last changed timestamp of an OSM object */
    CSVField[CSVField["Timestamp"] = 6] = "Timestamp";
    /* Changeset in which the object was changed */
    CSVField[CSVField["Changeset"] = 7] = "Changeset";
    /* OSM User id */
    CSVField[CSVField["UserId"] = 8] = "UserId";
    /* OSM User name */
    CSVField[CSVField["UserName"] = 9] = "UserName";
    /**
     * The following meta information fields are only available if out count;
     * Is used to output OSM elements.
     */
    /* Returns total number of objects (nodes, ways, relations and areas) in inputset */
    CSVField[CSVField["Count"] = 10] = "Count";
    /* Returns number of nodes in inputset */
    CSVField[CSVField["NodeCount"] = 11] = "NodeCount";
    /* Returns number of ways in inputset */
    CSVField[CSVField["WayCount"] = 12] = "WayCount";
    /* Returns number of relations in inputset */
    CSVField[CSVField["RelationCount"] = 13] = "RelationCount";
    /* Returns number of areas in inputset  */
    CSVField[CSVField["AreaCount"] = 14] = "AreaCount";
})(CSVField || (CSVField = {}));

class OverpassRecurseStatement extends ComposableOverpassStatementBase {
    constructor(recurseType, set) {
        super();
        this.recurseType = recurseType;
        this.set = set;
    }
    compile(u) {
        const recurse = u.recurse(this.recurseType);
        if (this.set != null) {
            return u.template `.${u.set(this.set)} ${recurse}`;
        }
        else {
            return recurse.asString();
        }
    }
}
const TARGETS$1 = {
    [OverpassQueryTarget.Node]: "n",
    [OverpassQueryTarget.Way]: "w",
    [OverpassQueryTarget.Relation]: "r",
};
class OverpassRecurseFilterStatementImp extends ChainableOverpassStatementBase {
    constructor(target, chain, type, back, set, role) {
        super(target, chain);
        this.type = type;
        this.back = back;
        this.set = set;
        this.role = role;
    }
    inSet(set) {
        return new OverpassRecurseFilterStatementImp(this.target, this.chain, this.type, this.back, set, this.role);
    }
    withRole(role) {
        return new OverpassRecurseFilterStatementImp(this.target, this.chain, this.type, this.back, this.set, role);
    }
    withoutRole() {
        return new OverpassRecurseFilterStatementImp(this.target, this.chain, this.type, this.back, this.set, "");
    }
    compileSetRole(u) {
        if (this.set != null && this.role != null) {
            return u.template `.${u.set(this.set)}:${u.qString(this.role)}`;
        }
        else if (this.set != null) {
            return u.template `.${u.set(this.set)}`;
        }
        else if (this.role != null) {
            return u.template `:${u.qString(this.role)}`;
        }
        else {
            return null;
        }
    }
    compileTarget(u) {
        const target = u.target(this.type).transform((target) => {
            if (!(target in TARGETS$1)) {
                throw new OverpassParameterError(`Unexpected recurse type ${target}`);
            }
            return TARGETS$1[target];
        });
        if (this.back)
            return u.template `b${target}`;
        else
            return target;
    }
    compileChainable(u) {
        const target = this.compileTarget(u);
        const setRole = this.compileSetRole(u);
        if (setRole != null) {
            return [u.template `(${target}${setRole})`];
        }
        else {
            return [u.template `(${target})`];
        }
    }
}

function enumObjectToArray(object) {
    const entries = Object.entries(object);
    const values = new Array(entries.length);
    entries.forEach(([key, value]) => {
        values[+key] = value;
    });
    return [...values];
}

const OP_FORMAT = enumObjectToArray({
    [OverpassFormat.XML]: "xml",
    [OverpassFormat.JSON]: "json",
    [OverpassFormat.JSONText]: "json",
    [OverpassFormat.CSV]: "csv",
    [OverpassFormat.Custom]: "custom",
    [OverpassFormat.Popup]: "popup",
});
const CSV_FIELDS = {
    [CSVField.Id]: "id",
    [CSVField.Type]: "type",
    [CSVField.OType]: "otype",
    [CSVField.Latitude]: "lat",
    [CSVField.Longitude]: "lon",
    [CSVField.Version]: "version",
    [CSVField.Timestamp]: "timestamp",
    [CSVField.Changeset]: "changeset",
    [CSVField.UserId]: "uid",
    [CSVField.UserName]: "user",
    [CSVField.Count]: "count",
    [CSVField.NodeCount]: "count:nodes",
    [CSVField.WayCount]: "count:ways",
    [CSVField.RelationCount]: "count:relations",
    [CSVField.AreaCount]: "count:areas",
};
class OverpassSettingsStatement extends OverpassStatementBase {
    constructor(settings) {
        super();
        this.settings = settings;
    }
    static HasSettings(settings) {
        return settings != null && Object.keys(settings).length > 0;
    }
    static BuildSettings(settings) {
        if (!OverpassSettingsStatement.HasSettings(settings)) {
            throw new Error(`An ${this.name} should not be constructed without settings`);
        }
        if (settings.format == OverpassFormat.CSV && settings.csvSettings == null) {
            throw new Error(`csvSettings are required when format is ${OverpassFormat[OverpassFormat.CSV]}`);
        }
        return new OverpassSettingsStatement(settings);
    }
    compileFormat(u) {
        if (this.settings.format != OverpassFormat.CSV) {
            return u.raw(`[out:${OP_FORMAT[this.settings.format]}]`);
        }
        else {
            const { fields, delimiterCharacter, headerLine } = this.settings.csvSettings;
            const fieldStr = fields
                .map((field) => (typeof field == "string" ? field : `::${CSV_FIELDS[field]}`))
                .join(", ");
            if (headerLine != null || delimiterCharacter != null) {
                if (delimiterCharacter != null) {
                    return u.raw(`[out:csv(${fieldStr}; ${headerLine !== null && headerLine !== void 0 ? headerLine : true}; "${delimiterCharacter}")]`);
                }
                else {
                    return u.raw(`[out:csv(${fieldStr}; ${headerLine})]`);
                }
            }
            else {
                return u.raw(`[out:csv(${fieldStr})]`);
            }
        }
    }
    compile(u) {
        const { timeout, maxSize, globalBoundingBox, date, diff } = this.settings;
        const options = [];
        if (timeout != null) {
            options.push(u.template `[timeout:${u.number(timeout)}]`);
        }
        if (maxSize != null) {
            options.push(u.template `[maxsize:${u.number(maxSize)}]`);
        }
        if (this.settings.format != null) {
            options.push(this.compileFormat(u));
        }
        if (globalBoundingBox != null) {
            const [s, w, n, e] = u.bbox(globalBoundingBox);
            options.push(u.template `[bbox:${s},${w},${n},${e}]`);
        }
        if (date != null) {
            options.push(u.template `[date:"${u.date(date)}"]`);
        }
        if (diff != null) {
            if (diff instanceof Array) {
                const [start, end] = diff;
                options.push(u.template `[diff:"${u.date(start)}","${u.date(end)}"]`);
            }
            else {
                options.push(u.template `[diff:"${u.date(diff)}"]`);
            }
        }
        return u.join(options, "\n");
    }
}

class OverpassStatementTargetImp {
    constructor(target, sets) {
        this.target = target;
        this.sets = sets;
    }
    withIntersection(set1, ...sets) {
        return new OverpassStatementTargetImp(this.target, [set1, ...sets]);
    }
    compile(u) {
        const target = u.target(this.target);
        if (this.sets.length == 0) {
            // ie: node => node(id)
            return target.asString();
        }
        else {
            // ie: node.set1.set2 => node.set1.set2(id)
            const sets = this.sets.map((set) => u.set(set));
            return u.template `${target}.${u.join(sets, ".")}`;
        }
    }
}

var HttpMethod;
(function (HttpMethod) {
    HttpMethod[HttpMethod["Get"] = 0] = "Get";
    HttpMethod[HttpMethod["Post"] = 1] = "Post";
})(HttpMethod || (HttpMethod = {}));

const TARGETS = {
    node: OverpassQueryTarget.Node,
    way: OverpassQueryTarget.Way,
    relation: OverpassQueryTarget.Relation,
    any: OverpassQueryTarget.NodeWayRelation,
};
function AnyTargetToQueryTarget(anyTarget) {
    return typeof anyTarget == "string" ? TARGETS[anyTarget] : anyTarget;
}

class OverpassTargetStateBase {
    constructor(target, chain, utils, tagBuilder, evaluatorItemBuilder) {
        this.target = target;
        this.chain = chain;
        this.utils = utils;
        this.tagBuilder = tagBuilder;
        this.evaluatorItemBuilder = evaluatorItemBuilder;
        if (chain == null) {
            chain = this;
        }
    }
    isRegExpTuple(tuple) {
        const prop = tuple[0];
        return prop instanceof RegExp || (prop instanceof ParamItem && prop.isType(ParamType.RegExp));
    }
    anyFilterToHelper(anyTag) {
        if (anyTag == null) {
            throw new OverpassParameterError(`Unexpected query filter value null`);
        }
        else if (typeof anyTag == "string" || (anyTag instanceof ParamItem && anyTag.isType(ParamType.String))) {
            return this.tagBuilder.equals(anyTag);
        }
        else if (anyTag instanceof RegExp || (anyTag instanceof ParamItem && anyTag.isType(ParamType.RegExp))) {
            return this.tagBuilder.regExp(anyTag);
        }
        else {
            return anyTag;
        }
    }
    byTags(tagInput) {
        const tags = [];
        let tagData;
        if (typeof tagInput == "function") {
            tagData = tagInput(this.tagBuilder);
        }
        else {
            tagData = tagInput;
        }
        if (tagData instanceof Array) {
            tagData.forEach((tuple) => {
                if (this.isRegExpTuple(tuple)) {
                    const [regExpProp, value] = tuple;
                    tags.push(this.tagBuilder.regExp(value).complete(regExpProp));
                }
                else {
                    const [prop, value] = tuple;
                    tags.push(this.anyFilterToHelper(value).complete(prop));
                }
            });
        }
        else {
            Object.entries(tagData).forEach(([prop, anyTagValue]) => {
                if (anyTagValue instanceof Array) {
                    tags.push(...anyTagValue.map((anyTag) => this.anyFilterToHelper(anyTag).complete(prop)));
                }
                else {
                    tags.push(this.anyFilterToHelper(anyTagValue).complete(prop));
                }
            });
        }
        return new OverpassByTagsStatement(this.target, this.chain, tags);
    }
    query(tagFilter) {
        console.warn("Method query has been deprecated since 1.8.0, will be removed on 2.x.x, use byTags");
        return this.byTags(tagFilter);
    }
    bbox(p1, ...rest) {
        const bbox = typeof p1 == "number" ? [p1, ...rest] : p1;
        return new OverpassBBoxStatement(this.target, this.chain, bbox);
    }
    byId(id) {
        return new OverpassByIdStatement(this.target, this.chain, id);
    }
    static PositionLiteralToGeoPosExp(literal) {
        return literal instanceof Array ? { lat: literal[0], lon: literal[1] } : literal;
    }
    inside(polygon) {
        return new OverpassInsidePolygonStatement(this.target, this.chain, polygon.map(OverpassTargetStateBase.PositionLiteralToGeoPosExp));
    }
    filter(predicate) {
        return new OverpassIfFilterStatement(this.target, this.chain, predicate(this.evaluatorItemBuilder));
    }
    aroundCenter(radius, center) {
        return new OverpassAroundCenterStatement(this.target, this.chain, radius, center);
    }
    aroundSet(radius, set) {
        return new OverpassAroundSetStatement(this.target, this.chain, radius, set);
    }
    aroundLine(radius, line) {
        return new OverpassAroundLineStatement(this.target, this.chain, radius, line.map(OverpassTargetStateBase.PositionLiteralToGeoPosExp));
    }
    inArea(set) {
        return new OverpassAreaStatement(this.target, this.chain, set);
    }
    pivot(set) {
        return new OverpassPivotStatement(this.target, this.chain, set);
    }
    recurseFrom(anyType, inSet, withRole) {
        const type = AnyTargetToQueryTarget(anyType);
        return new OverpassRecurseFilterStatementImp(this.target, this.chain, type, false, inSet, withRole);
    }
    recurseBackwards(anyType, inSet, withRole) {
        const type = AnyTargetToQueryTarget(anyType);
        return new OverpassRecurseFilterStatementImp(this.target, this.chain, type, true, inSet, withRole);
    }
}

class OverpassChainableIntersectStatement extends OverpassTargetStateBase {
    union(statement) {
        return new OverpassUnionStatement(this, statement);
    }
    difference(statement) {
        return new OverpassDifferenceStatement(this, statement);
    }
    toSet(set) {
        return new OverpassSetStatement(this, set);
    }
    compile(u) {
        return this.target.compile(u);
    }
}

class OverpassTargetMapStateImp extends OverpassTargetStateBase {
    intersect(set1, ...sets) {
        return new OverpassChainableIntersectStatement(this.target.withIntersection(set1, ...sets), this.chain, this.utils, this.tagBuilder, this.evaluatorItemBuilder);
    }
}

const STATEMENT_METHOD = (function () {
    const enumObj = {
        bbox: true,
        byId: true,
        query: true,
        inside: true,
        byTags: true,
        filter: true,
        aroundCenter: true,
        aroundLine: true,
        aroundSet: true,
        inArea: true,
        pivot: true,
        recurseFrom: true,
        recurseBackwards: true,
    };
    return Object.keys(enumObj);
})();
const STRING_TARGETS = Object.keys(TARGETS);
class OverpassStateImp {
    constructor(utils, tagBuilder, evaluatorItemBuilder) {
        this.utils = utils;
        this.tagBuilder = tagBuilder;
        this.evaluatorItemBuilder = evaluatorItemBuilder;
        this.targets = new Map();
        this.functions = {};
        const stateProxy = new Proxy(this, { get: this.proxyGet });
        this.proxy = stateProxy;
        this.chain = new OverpassTargetMapStateImp(null, null, this.utils, this.tagBuilder, this.evaluatorItemBuilder);
    }
    static Build(utils, tagBuilder, evaluatorItemBuilder) {
        const state = new OverpassStateImp(utils, tagBuilder, evaluatorItemBuilder);
        return state.proxy;
    }
    getTarget(anyTarget) {
        const target = AnyTargetToQueryTarget(anyTarget);
        let targetState = this.targets.get(target);
        if (targetState == null) {
            const statementTarget = new OverpassStatementTargetImp(target, []);
            targetState = new OverpassTargetMapStateImp(statementTarget, this.chain, this.utils, this.tagBuilder, this.evaluatorItemBuilder);
            this.targets.set(target, targetState);
        }
        return targetState;
    }
    buildFunction(state, prop) {
        return (target, ...args) => state.getTarget(target)[prop](...args);
    }
    getFunction(state, prop) {
        let funct = this.functions[prop];
        if (funct == null) {
            this.functions[prop] = this.buildFunction(state, prop);
            funct = this.functions[prop];
        }
        return funct;
    }
    proxyGet(state, prop) {
        if (typeof prop == "string") {
            if (STRING_TARGETS.includes(prop)) {
                return state.getTarget(prop);
            }
            else if (STATEMENT_METHOD.includes(prop)) {
                return state.getFunction(state, prop);
            }
            else if (!isNaN(+prop)) {
                return state.getTarget(+prop);
            }
        }
        return state[prop];
    }
    statement(input) {
        return new OverpassRawStatement(typeof input == "string" ? (u) => u.raw(input) : input);
    }
    composableStatement(input) {
        return new OverpassComposableRawStatement(typeof input == "string" ? (u) => u.raw(input) : input);
    }
    set(anyTargetExp, set) {
        return this.intersect(anyTargetExp, set);
    }
    intersect(anyTargetExp, set1, ...sets) {
        const target = AnyTargetToQueryTarget(anyTargetExp);
        const statementTarget = new OverpassStatementTargetImp(target, [set1, ...sets]);
        return new OverpassChainableIntersectStatement(statementTarget, this.chain, this.utils, this.tagBuilder, this.evaluatorItemBuilder);
    }
    recurse(type, input) {
        return new OverpassRecurseStatement(type, input);
    }
    out(options) {
        return new OverpassOutStatement(options);
    }
    forEach(setOrBody, itemOrBody, maybeBody) {
        let body;
        let set;
        let item;
        if (maybeBody instanceof Function) {
            body = maybeBody;
            set = setOrBody;
            item = itemOrBody;
        }
        else if (itemOrBody instanceof Function) {
            body = itemOrBody;
            set = setOrBody;
        }
        else {
            body = setOrBody;
            set = null;
        }
        return new OverpassForEachStatement(body, set, item);
    }
}

class OverpassApiObjectImp {
    constructor(adapter, interpreterUrl, statusUrl, queryValidator, statusValidator, compileUtils, tagBuilder, evaluatorItemBuilder) {
        this.adapter = adapter;
        this.interpreterUrl = interpreterUrl;
        this.statusUrl = statusUrl;
        this.queryValidator = queryValidator;
        this.statusValidator = statusValidator;
        this.compileUtils = compileUtils;
        this.tagBuilder = tagBuilder;
        this.evaluatorItemBuilder = evaluatorItemBuilder;
    }
    /** @deprecated since 1.8.1, will be removed on 2.x.x, use root function {@link BuildOverpassApi} */
    static Build(adapter, interpreterUrlInput, statusUrlInput) {
        console.warn("Method OverpassApiObjectImp.Build has been deprecated since 1.8.1");
        console.warn("Will be removed on 2.x.x, use root function BuildOverpassApi");
        return OverpassApiObjectImp.BuildDeprecated(adapter, interpreterUrlInput, statusUrlInput);
    }
    /** @deprecated since 1.8.1, will be removed on 2.x.x, use root function {@link InterpreterUrlFrom} */
    static InterpreterUrlFrom(interpreterUrlInput) {
        console.warn("Method OverpassApiObjectImp.InterpreterUrlFrom has been deprecated since 1.8.1");
        console.warn("Will be removed on 2.x.x, use root function InterpreterUrlFrom");
        return OverpassApiObjectImp.InterpreterUrlFromDeprecated(interpreterUrlInput);
    }
    /** @deprecated since 1.8.1, will be removed on 2.x.x, use root function {@link StatusUrlFrom} */
    static StatusUrlFrom(interpreterUrl, statusUrl) {
        console.warn("Method OverpassApiObjectImp.StatusUrlFrom has been deprecated since 1.8.1");
        console.warn("Will be removed on 2.x.x, use root function StatusUrlFrom");
        return OverpassApiObjectImp.StatusUrlFromDeprecated(interpreterUrl, statusUrl);
    }
    /** @deprecated since 1.8.1, will be removed on 2.x.x, use root function {@link StatusUrlFromInterpreterUrl} */
    static StatusUrlFromInterpreterUrl(interpreterUrl) {
        console.warn("Method OverpassApiObjectImp.StatusUrlFromInterpreterUrl has been deprecated since 1.8.1");
        console.warn("Will be removed on 2.x.x, use root function StatusUrlFromInterpreterUrl");
        return OverpassApiObjectImp.StatusUrlFromInterpreterUrlDeprecated(interpreterUrl);
    }
    get __adapter__() {
        return this.adapter;
    }
    compileParts(statements, options, settings) {
        if (statements.length == 0) {
            throw new Error(`You should provide at least 1 statement ... try node.byId(5431618355)`);
        }
        const stmCopy = statements.concat();
        if (OverpassSettingsStatement.HasSettings(settings)) {
            stmCopy.unshift(OverpassSettingsStatement.BuildSettings(settings));
        }
        if (!(options === null || options === void 0 ? void 0 : options.noGlobalOut)) {
            stmCopy.push(new OverpassOutStatement({ ...options }));
        }
        return this.compileUtils.join(stmCopy.map((stm) => this.compileUtils.template `${stm.compile(this.compileUtils)};`), "\n");
    }
    buildQuery(statementBuilder, options, settings) {
        const state = OverpassStateImp.Build(this.compileUtils, this.tagBuilder, this.evaluatorItemBuilder);
        const statements = statementBuilder(state);
        const compiledQuery = this.compileParts(statements instanceof Array ? statements : [statements], options, settings);
        return compiledQuery.compile([]);
    }
    async doRequest(query) {
        return await this.adapter.request(this.interpreterUrl, {
            method: HttpMethod.Post,
            body: `data=${encodeURIComponent(query)}`,
        });
    }
    async exec(settings, statementBuilder, options) {
        var _a;
        const query = this.buildQuery(statementBuilder, { ...options }, settings);
        const httpResponse = await this.doRequest(query);
        return this.queryValidator.validate(query, httpResponse, (_a = settings.format) !== null && _a !== void 0 ? _a : OverpassFormat.XML);
    }
    execJson(statementBuilder, options, settings) {
        return this.exec({ ...settings, format: OverpassFormat.JSON }, statementBuilder, options);
    }
    getUnknownFormat({ contentType }) {
        switch (contentType) {
            case "application/json":
                return OverpassFormat.JSON;
            case "application/osm3s+xml":
                return OverpassFormat.XML;
            case "text/csv":
                return OverpassFormat.CSV;
            default:
                return undefined;
        }
    }
    async execQuery(queryInput) {
        const query = typeof queryInput == "string" ? queryInput : queryInput(this.compileUtils).asString().simplify();
        const httpResponse = await this.doRequest(query);
        const format = this.getUnknownFormat(httpResponse);
        return this.queryValidator.validate(query, httpResponse, format);
    }
    static NormalizeOutput(output, outpOptions, settings) {
        if (output instanceof Array) {
            return { statements: output, outpOptions, settings };
        }
        else if ("statements" in output) {
            return output;
        }
        else {
            return { statements: [output], outpOptions, settings };
        }
    }
    createFunction(argTypes, statementBuilder, optionsInput, settingsInput) {
        const types = argTypes.map((type, i) => new ParamItem(i, type));
        const state = OverpassStateImp.Build(this.compileUtils, this.tagBuilder, this.evaluatorItemBuilder);
        const builderOutput = statementBuilder(state, ...types);
        const { statements, outpOptions, settings } = OverpassApiObjectImp.NormalizeOutput(builderOutput, optionsInput, settingsInput);
        const compiledQuery = this.compileParts(statements, { ...outpOptions }, { ...settings, format: OverpassFormat.JSON });
        return async (...args) => {
            const query = compiledQuery.compile(args);
            const httpResponse = await this.doRequest(query);
            return this.queryValidator.validate(query, httpResponse, OverpassFormat.JSON);
        };
    }
    async status() {
        const result = await this.adapter.request(this.statusUrl);
        return this.statusValidator.validate(result);
    }
}
OverpassApiObjectImp.MAIN_INSTANCE = new URL("https://overpass-api.de/api/interpreter");

class NaiveOverpassStringSanitizer {
    sanitize(str, quote = StringQuoteType.Double) {
        for (let i = 0; i < str.length; i++) {
            const current = str.charAt(i);
            switch (current) {
                case "'":
                case '"': {
                    if (current == quote) {
                        str = `${str.substring(0, i)}\\${str.substring(i)}`;
                        i += 2;
                    }
                    break;
                }
                case "\\": {
                    let amount = 1;
                    while (str.charAt(i + amount) == "\\") {
                        amount++;
                    }
                    i += amount - 1;
                    if (amount % 2 == 1) {
                        if (i == str.length - 1) {
                            str = `${str}\\`;
                            i += 2;
                        }
                        else {
                            switch (str.charAt(i + 1)) {
                                case "n":
                                case "t":
                                case "'":
                                case '"':
                                    i++;
                                    break;
                                default: {
                                    str = `${str.substring(0, i)}\\${str.substring(i)}`;
                                    i += 2;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                }
            }
        }
        return str;
    }
}
class NoOverpassStringSanitizer {
    sanitize(str, quote) {
        return str;
    }
}

class TransformCompiledItem {
    constructor(item, callback) {
        this.item = item;
        this.callback = callback;
    }
    isSimplifiable() {
        return this.item.isSimplifiable();
    }
    simplify() {
        return this.callback(this.item.simplify());
    }
    transform(callback) {
        return new TransformCompiledItem(this, callback);
    }
    asString() {
        return this;
    }
    resolve(params) {
        return this.compile(params);
    }
    compile(params) {
        return this.callback(this.item.resolve(params));
    }
}

class BaseParamCompiledItem {
    constructor(value) {
        this.value = value;
    }
    isSimplifiable() {
        return !(this.value instanceof ParamItem);
    }
    simplify() {
        if (this.value instanceof ParamItem) {
            throw new Error(`Tried to simplify a parameter`);
        }
        else {
            return this.validateParam(this.value);
        }
    }
    transform(callback) {
        return new TransformCompiledItem(this, callback);
    }
    asString() {
        return new TransformCompiledItem(this, this.compilePram.bind(this));
    }
    getValue(params) {
        if (this.value instanceof ParamItem) {
            const { index, type } = this.value;
            if (params.length <= index) {
                throw new Error(`Missing parameter for [${index}](${ParamType[type]}), got ${params.length} in total`);
            }
            return params[index];
        }
        else {
            return this.value;
        }
    }
    resolve(params) {
        return this.validateParam(this.getValue(params));
    }
    compile(params) {
        return this.compilePram(this.resolve(params));
    }
}

function isValidNumber(number) {
    return typeof number == "number" && !isNaN(number) && isFinite(number);
}
var Axis;
(function (Axis) {
    Axis[Axis["Lat"] = 0] = "Lat";
    Axis[Axis["Lon"] = 1] = "Lon";
})(Axis || (Axis = {}));
const AXIS_RANGE = { [Axis.Lat]: 90, [Axis.Lon]: 180 };
function isOutOfRange(number, axis) {
    return Math.abs(number) > AXIS_RANGE[axis];
}

const BBOX_SEED = [0, 0, 0, 0];
const DIRECTIONS = ["south", "west", "north", "east"];
class BBoxParamCompiledItem extends BaseParamCompiledItem {
    constructor(value, dirIndex) {
        super(value);
        this.dirIndex = dirIndex;
    }
    static BBox(value) {
        const bbox = BBOX_SEED.map((_, dirIndex) => new BBoxParamCompiledItem(value, dirIndex));
        return bbox;
    }
    validateParam(param) {
        if (param == null) {
            throw new OverpassParameterError(`Unexpected BoundingBox value (${param})`);
        }
        const value = param[this.dirIndex];
        if (!isValidNumber(value)) {
            throw new OverpassParameterError(`Unexpected BoundingBox ${DIRECTIONS[this.dirIndex]} value (${param})`);
        }
        if (isOutOfRange(value, this.dirIndex % 2 == 0 ? Axis.Lat : Axis.Lon)) {
            throw new OverpassParameterError(`BoundingBox ${DIRECTIONS[this.dirIndex]} out of range (${value})`);
        }
        return value;
    }
    compilePram(param) {
        return param.toString();
    }
}

class BooleanParamCompiledItem extends BaseParamCompiledItem {
    validateParam(param) {
        if (param == null) {
            throw new OverpassParameterError(`Unexpected boolean value (${param})`);
        }
        if (typeof param != "boolean") {
            throw new OverpassParameterError(`Unexpected boolean value (${param})`);
        }
        return param;
    }
    compilePram(param) {
        return param ? "1" : "0";
    }
}

class DateParamCompiledItem extends BaseParamCompiledItem {
    validateParam(param) {
        if (!(param instanceof Date)) {
            throw new OverpassParameterError(`Unexpected Date value (${param})`);
        }
        if (isNaN(param.getTime())) {
            throw new OverpassParameterError(`Invalid Date (${param.getTime()})`);
        }
        return param;
    }
    compilePram(param) {
        return param.toISOString();
    }
}

const ENUM_STRINGS = {
    [ParamType.Target]: enumObjectToArray({
        [OverpassQueryTarget.Node]: "node",
        [OverpassQueryTarget.Way]: "way",
        [OverpassQueryTarget.NodeWay]: "nw",
        [OverpassQueryTarget.Relation]: "rel",
        [OverpassQueryTarget.NodeRelation]: "nr",
        [OverpassQueryTarget.WayRelation]: "wr",
        [OverpassQueryTarget.NodeWayRelation]: "nwr",
        [OverpassQueryTarget.Area]: "area",
        [OverpassQueryTarget.Derived]: "derived",
    }),
    [ParamType.Verbosity]: enumObjectToArray({
        [OverpassOutputVerbosity.Ids]: "ids",
        [OverpassOutputVerbosity.Geometry]: "skel",
        [OverpassOutputVerbosity.Body]: "body",
        [OverpassOutputVerbosity.Tags]: "tags",
        [OverpassOutputVerbosity.Metadata]: "meta",
    }),
    [ParamType.GeoInfo]: enumObjectToArray({
        [OverpassOutputGeoInfo.Geometry]: "geom",
        [OverpassOutputGeoInfo.BoundingBox]: "bb",
        [OverpassOutputGeoInfo.Center]: "center",
    }),
    [ParamType.SortOrder]: enumObjectToArray({
        [OverpassSortOrder.Ascending]: "asc",
        [OverpassSortOrder.QuadtileIndex]: "qt",
    }),
    [ParamType.RecurseStm]: enumObjectToArray({
        [OverpassRecurseStmType.Up]: "<",
        [OverpassRecurseStmType.Down]: ">",
        [OverpassRecurseStmType.UpRelations]: "<<",
        [OverpassRecurseStmType.DownRelations]: ">>",
    }),
};
class EnumParamCompiledItem extends BaseParamCompiledItem {
    constructor(type, value) {
        super(value);
        this.type = type;
    }
    getEnumObject(type) {
        switch (type) {
            case ParamType.Target:
                return OverpassQueryTarget;
            case ParamType.Verbosity:
                return OverpassOutputVerbosity;
            case ParamType.GeoInfo:
                return OverpassOutputGeoInfo;
            case ParamType.SortOrder:
                return OverpassSortOrder;
            case ParamType.RecurseStm:
                return OverpassRecurseStmType;
        }
    }
    validateParam(param) {
        if (!isValidNumber(param)) {
            throw new OverpassParameterError(`Unexpected target value (${param})`);
        }
        const enumObject = this.getEnumObject(this.type);
        if (!(param in enumObject)) {
            throw new OverpassParameterError(`Unexpected Enum value (${enumObject[param]})`);
        }
        return param;
    }
    compilePram(param) {
        return ENUM_STRINGS[this.type][param];
    }
}

class GeoPosParamCompiledItem extends BaseParamCompiledItem {
    constructor(value, coord) {
        super(value);
        this.coord = coord;
    }
    static GeoPos(value) {
        return {
            lat: new GeoPosParamCompiledItem(value, "lat"),
            lon: new GeoPosParamCompiledItem(value, "lon"),
        };
    }
    validateParam(param) {
        if (param == null) {
            throw new OverpassParameterError(`Unexpected GeoPos value (${param})`);
        }
        const value = param[this.coord];
        if (!isValidNumber(value)) {
            throw new OverpassParameterError(`Unexpected GeoPos ${this.coord} value (${param})`);
        }
        if (isOutOfRange(value, this.coord == "lat" ? Axis.Lat : Axis.Lon)) {
            throw new OverpassParameterError(`GeoPos ${this.coord} out of range (${value})`);
        }
        return value;
    }
    compilePram(param) {
        return param.toString();
    }
}

class NumberParamCompiledItem extends BaseParamCompiledItem {
    validateParam(param) {
        if (!isValidNumber(param)) {
            throw new OverpassParameterError(`Unexpected number value (${param})`);
        }
        return param;
    }
    compilePram(param) {
        return param.toString();
    }
}

class RegExpParamCompiledItem extends BaseParamCompiledItem {
    validateParam(param) {
        if (!(param instanceof RegExp)) {
            throw new OverpassParameterError(`Unexpected RegExp value (${param})`);
        }
        return param;
    }
    compilePram(param) {
        return `"${param.source}"`;
    }
}

class SetParamCompiledItem extends BaseParamCompiledItem {
    validateParam(param) {
        if (typeof param != "string") {
            throw new OverpassParameterError(`Unexpected set value (${param})`);
        }
        return param;
    }
    compilePram(param) {
        return param;
    }
}

class StringParamCompiledItem extends BaseParamCompiledItem {
    constructor(sanitizer, value) {
        super(value);
        this.sanitizer = sanitizer;
    }
    validateParam(param) {
        if (typeof param != "string") {
            throw new OverpassParameterError(`Unexpected string value (${param})`);
        }
        return param;
    }
    compilePram(param) {
        return `"${this.sanitizer.sanitize(param)}"`;
    }
}

class ParentCompiledItem {
    constructor(parts) {
        this.subParts = ParentCompiledItem.SimplifyAndFlatten(parts);
    }
    static SimplifyAndFlatten(parts) {
        const subParts = parts
            .map((part) => {
            if (typeof part == "string")
                return [part];
            else if (part instanceof ParentCompiledItem)
                return part.subParts;
            else {
                const strItem = part.asString();
                return [strItem.isSimplifiable() ? strItem.simplify() : strItem];
            }
        })
            .flat();
        for (let i = subParts.length - 2; i >= 0; i--) {
            const current = subParts[i];
            const next = subParts[i + 1];
            if (typeof current == "string") {
                if (typeof next == "string") {
                    subParts.splice(i, 2, current + next);
                }
            }
            else {
                i--;
            }
        }
        return subParts;
    }
    isSimplifiable() {
        return this.subParts.every((part) => typeof part == "string" || part.isSimplifiable());
    }
    simplify() {
        const unSimplifiable = this.subParts.find((part) => typeof part != "string");
        if (unSimplifiable != null) {
            throw new Error(`Unable to simplify expression ${unSimplifiable.constructor.name}`);
        }
        return this.subParts.join("");
    }
    transform(callback) {
        return new TransformCompiledItem(this, callback);
    }
    asString() {
        return this;
    }
    resolve(params) {
        return this.compile(params);
    }
    compile(params) {
        return this.subParts.map((part) => (typeof part == "string" ? part : part.compile(params))).join("");
    }
}

class OverpassCompileUtils {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.nl = this.raw("\n");
    }
    qString(value) {
        return new StringParamCompiledItem(this.sanitizer, value);
    }
    number(value) {
        return new NumberParamCompiledItem(value);
    }
    set(value) {
        return new SetParamCompiledItem(value);
    }
    target(value) {
        return new EnumParamCompiledItem(ParamType.Target, value);
    }
    geoInfo(value) {
        return new EnumParamCompiledItem(ParamType.GeoInfo, value);
    }
    sortOrder(value) {
        return new EnumParamCompiledItem(ParamType.SortOrder, value);
    }
    verbosity(value) {
        return new EnumParamCompiledItem(ParamType.Verbosity, value);
    }
    recurse(value) {
        return new EnumParamCompiledItem(ParamType.RecurseStm, value);
    }
    regExp(value) {
        return new RegExpParamCompiledItem(value);
    }
    date(value) {
        return new DateParamCompiledItem(value);
    }
    bbox(bboxExp) {
        return BBoxParamCompiledItem.BBox(bboxExp);
    }
    geoPos(value) {
        return GeoPosParamCompiledItem.GeoPos(value);
    }
    boolean(value) {
        return new BooleanParamCompiledItem(value);
    }
    raw(string) {
        return new ParentCompiledItem([string]);
    }
    join(expressions, separator) {
        return new ParentCompiledItem(expressions
            .map((part) => [part, separator])
            .flat()
            .slice(0, -1));
    }
    template(strings, ...expr) {
        return new ParentCompiledItem(strings.raw
            .map((part, i) => [part, expr[i]])
            .flat()
            .slice(0, -1));
    }
}

class OverpassEvaluatorNodeImp {
}

class OverpassConditionalEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(condition, ifTrue, ifFalse) {
        super();
        this.condition = condition;
        this.ifTrue = ifTrue;
        this.ifFalse = ifFalse;
    }
    compile(u) {
        return u.template `(${this.condition.compile(u)} ? ${this.ifTrue.compile(u)} : ${this.ifFalse.compile(u)})`;
    }
}

class OverpassCountTagsEvaluatorNode extends OverpassEvaluatorNodeImp {
    compile(u) {
        return u.raw("count_tags()");
    }
}
class OverpassCountMembersEvaluatorNode extends OverpassEvaluatorNodeImp {
    compile(u) {
        return u.raw("count_members()");
    }
}
class OverpassCountMembersDistinctEvaluatorNode extends OverpassEvaluatorNodeImp {
    compile(u) {
        return u.raw("count_distinct_members()");
    }
}
class OverpassCountByRoleEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(role) {
        super();
        this.role = role;
    }
    compile(u) {
        return u.template `count_by_role(${this.role.compile(u)})`;
    }
}
class OverpassCountByRoleDistinctEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(role) {
        super();
        this.role = role;
    }
    compile(u) {
        return u.template `count_distinct_by_role(${this.role.compile(u)})`;
    }
}

class OverpassElementIdEvaluatorNode extends OverpassEvaluatorNodeImp {
    compile(u) {
        return u.raw("id()");
    }
}
class OverpassElementTypeEvaluatorNode extends OverpassEvaluatorNodeImp {
    compile(u) {
        return u.raw("type()");
    }
}
class OverpassElementHasTypeEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    compile(u) {
        return u.template `is_tag(${u.qString(this.tag)})`;
    }
}
class OverpassElementGetTypeEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    compile(u) {
        return u.template `t[${u.qString(this.tag)}]`;
    }
}

class OverpassEqualsEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self, other) {
        super();
        this.self = self;
        this.other = other;
    }
    compile(u) {
        return u.template `(${this.self.compile(u)} == ${this.other.compile(u)})`;
    }
}
class OverpassNotEqualsEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self, other) {
        super();
        this.self = self;
        this.other = other;
    }
    compile(u) {
        return u.template `(${this.self.compile(u)} != ${this.other.compile(u)})`;
    }
}

class OverpassEvaluatorImp {
    constructor(node) {
        this.node = node;
    }
    evaluatorFromExp(evaluator) {
        return evaluator instanceof OverpassEvaluatorImp
            ? evaluator
            : this.evaluatorFromRawExp(evaluator);
    }
    eq(evaluator) {
        return new OverpassEvaluatorImp.OverpassBooleanEvaluator(new OverpassEqualsEvaluatorNode(this, this.evaluatorFromExp(evaluator)));
    }
    neq(evaluator) {
        return new OverpassEvaluatorImp.OverpassBooleanEvaluator(new OverpassNotEqualsEvaluatorNode(this, this.evaluatorFromExp(evaluator)));
    }
    compile(utils) {
        return this.node.compile(utils);
    }
}

class OverpassRawEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(compileFn) {
        super();
        this.compileFn = compileFn;
    }
    compile(u) {
        return this.compileFn(u).asString().asString();
    }
}

class OverpassNotEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self) {
        super();
        this.self = self;
    }
    compile(u) {
        return u.template `!${this.self.compile(u)}`;
    }
}

class OverpassOperatorEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(operator, conditions) {
        super();
        this.operator = operator;
        this.conditions = conditions;
    }
    compile(u) {
        const conditions = this.conditions.map((condition) => condition.compile(u));
        return u.template `(${u.join(conditions, ` ${this.operator} `)})`;
    }
}

class OverpassBooleanEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    compile(u) {
        return u.template `"${u.boolean(this.expression)}"`;
    }
}
class OverpassBooleanEvaluatorThenImp {
    constructor(condition, ifTrue) {
        this.condition = condition;
        this.ifTrue = ifTrue;
    }
    else(ifFalse) {
        return this.condition.conditional(this.ifTrue, ifFalse);
    }
}
class OverpassBooleanEvaluatorImp extends OverpassEvaluatorImp {
    static From(value) {
        if (value instanceof OverpassBooleanEvaluatorImp) {
            return value;
        }
        else {
            return new OverpassBooleanEvaluatorImp(new OverpassBooleanEvaluatorNode(value));
        }
    }
    evaluatorFromRawExp(expression) {
        return new OverpassBooleanEvaluatorImp(new OverpassBooleanEvaluatorNode(expression));
    }
    with(node) {
        return new OverpassBooleanEvaluatorImp(node);
    }
    not() {
        return new OverpassBooleanEvaluatorImp(new OverpassNotEvaluatorNode(this));
    }
    or(...conditions) {
        return new OverpassBooleanEvaluatorImp(new OverpassOperatorEvaluatorNode("||", [
            this,
            ...conditions.map((condition) => this.evaluatorFromExp(condition)),
        ]));
    }
    and(...conditions) {
        return new OverpassBooleanEvaluatorImp(new OverpassOperatorEvaluatorNode("&&", [
            this,
            ...conditions.map((condition) => this.evaluatorFromExp(condition)),
        ]));
    }
    conditional(ifTrue, ifFalse) {
        return ifTrue.with(new OverpassConditionalEvaluatorNode(this, ifTrue, ifFalse));
    }
    then(ifTrue) {
        return new OverpassBooleanEvaluatorThenImp(this, ifTrue);
    }
}
OverpassEvaluatorImp.OverpassBooleanEvaluator = OverpassBooleanEvaluatorImp;

const COMPARISSON_OPERATORS = {
    [OverpasComparissonOperator.Lower]: "<",
    [OverpasComparissonOperator.LowerOrEquals]: "<=",
    [OverpasComparissonOperator.GreaterOrEquals]: ">=",
    [OverpasComparissonOperator.Greater]: ">",
};
class OverpassComparissonEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
    compile(u) {
        const op = u.raw(COMPARISSON_OPERATORS[this.operator]);
        return u.template `(${this.left.compile(u)} ${op} ${this.right.compile(u)})`;
    }
}

class OverpassMagnitudeEvaluatorImp extends OverpassEvaluatorImp {
    compare(op, rightExp) {
        const right = this.evaluatorFromExp(rightExp);
        return new OverpassEvaluatorImp.OverpassBooleanEvaluator(new OverpassComparissonEvaluatorNode(this, op, right));
    }
    lt(right) {
        return this.compare(OverpasComparissonOperator.Lower, right);
    }
    le(right) {
        return this.compare(OverpasComparissonOperator.LowerOrEquals, right);
    }
    ge(right) {
        return this.compare(OverpasComparissonOperator.GreaterOrEquals, right);
    }
    gt(right) {
        return this.compare(OverpasComparissonOperator.Greater, right);
    }
}

class OverpassDateEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    compile(u) {
        return u.template `date("${u.date(this.expression)}")`;
    }
}
class OverpassDateEvaluatorImp extends OverpassMagnitudeEvaluatorImp {
    evaluatorFromRawExp(expression) {
        return new OverpassDateEvaluatorImp(new OverpassDateEvaluatorNode(expression));
    }
    static From(value) {
        return new OverpassDateEvaluatorImp(new OverpassDateEvaluatorNode(value));
    }
    with(node) {
        return new OverpassDateEvaluatorImp(node);
    }
}

class OverpassAbsEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self) {
        super();
        this.self = self;
    }
    compile(u) {
        return u.template `abs(${this.self.compile(u)})`;
    }
}

const ARITHMETIC_OPERATORS = {
    [OverpassArithmeticOperator.Add]: "+",
    [OverpassArithmeticOperator.Sub]: "-",
    [OverpassArithmeticOperator.Mult]: "*",
    [OverpassArithmeticOperator.Divide]: "/",
};
class OverpassArithmeticEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
    compile(u) {
        const op = u.raw(ARITHMETIC_OPERATORS[this.operator]);
        return u.template `(${this.left.compile(u)} ${op} ${this.right.compile(u)})`;
    }
}

class OverpassNumberEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    compile(u) {
        return u.number(this.expression).asString();
    }
}
class OverpassNumberEvaluatorImp extends OverpassMagnitudeEvaluatorImp {
    static From(value) {
        return new OverpassNumberEvaluatorImp(new OverpassNumberEvaluatorNode(value));
    }
    evaluatorFromRawExp(expression) {
        return new OverpassNumberEvaluatorImp(new OverpassNumberEvaluatorNode(expression));
    }
    with(node) {
        return new OverpassNumberEvaluatorImp(node);
    }
    abs() {
        return new OverpassNumberEvaluatorImp(new OverpassAbsEvaluatorNode(this));
    }
    op(op, rightExp) {
        const right = this.evaluatorFromExp(rightExp);
        return new OverpassNumberEvaluatorImp(new OverpassArithmeticEvaluatorNode(this, op, right));
    }
    plus(number) {
        return this.op(OverpassArithmeticOperator.Add, number);
    }
    minus(number) {
        return this.op(OverpassArithmeticOperator.Sub, number);
    }
    times(number) {
        return this.op(OverpassArithmeticOperator.Mult, number);
    }
    dividedBy(number) {
        return this.op(OverpassArithmeticOperator.Divide, number);
    }
}

class OverpassAsBooleanEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self) {
        super();
        this.self = self;
    }
    compile(u) {
        return this.self.compile(u);
    }
}

class OverpassIsDateEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self) {
        super();
        this.self = self;
    }
    compile(u) {
        return u.template `is_date(${this.self.compile(u)})`;
    }
}
class OverpassParseDateEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self) {
        super();
        this.self = self;
    }
    compile(u) {
        return u.template `date(${this.self.compile(u)})`;
    }
}

class OverpassIsNumberEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self) {
        super();
        this.self = self;
    }
    compile(u) {
        return u.template `is_number(${this.self.compile(u)})`;
    }
}
class OverpassParseNumberEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(self) {
        super();
        this.self = self;
    }
    compile(u) {
        return u.template `number(${this.self.compile(u)})`;
    }
}

class OverpassStringEvaluatorNode extends OverpassEvaluatorNodeImp {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    compile(u) {
        return u.qString(this.expression);
    }
}
class OverpassStringEvaluatorImp extends OverpassEvaluatorImp {
    static From(value) {
        if (value instanceof OverpassStringEvaluatorImp) {
            return value;
        }
        else {
            return new OverpassStringEvaluatorImp(new OverpassStringEvaluatorNode(value));
        }
    }
    evaluatorFromRawExp(expression) {
        return new OverpassStringEvaluatorImp(new OverpassStringEvaluatorNode(expression));
    }
    with(node) {
        return new OverpassStringEvaluatorImp(node);
    }
    isNumber() {
        return new OverpassEvaluatorImp.OverpassBooleanEvaluator(new OverpassIsNumberEvaluatorNode(this));
    }
    parseNumber() {
        return new OverpassNumberEvaluatorImp(new OverpassParseNumberEvaluatorNode(this));
    }
    isDate() {
        return new OverpassEvaluatorImp.OverpassBooleanEvaluator(new OverpassIsDateEvaluatorNode(this));
    }
    parseDate() {
        return new OverpassDateEvaluatorImp(new OverpassParseDateEvaluatorNode(this));
    }
    asBool() {
        return new OverpassBooleanEvaluatorImp(new OverpassAsBooleanEvaluatorNode(this));
    }
}

class OverpassEvaluatorBuilderImp {
    constructor() {
        this.true = OverpassBooleanEvaluatorImp.From(true);
        this.false = OverpassBooleanEvaluatorImp.From(false);
    }
    conditional(condition, ifTrue, ifFalse) {
        return OverpassBooleanEvaluatorImp.From(condition).conditional(ifTrue, ifFalse);
    }
    or(condition, ...conditions) {
        return OverpassBooleanEvaluatorImp.From(condition).or(...conditions);
    }
    and(condition, ...conditions) {
        return OverpassBooleanEvaluatorImp.From(condition).and(...conditions);
    }
    number(value) {
        return typeof value == "function"
            ? new OverpassNumberEvaluatorImp(new OverpassRawEvaluatorNode(value))
            : OverpassNumberEvaluatorImp.From(value);
    }
    string(value) {
        return typeof value == "function"
            ? new OverpassStringEvaluatorImp(new OverpassRawEvaluatorNode(value))
            : OverpassStringEvaluatorImp.From(value);
    }
    date(value) {
        return typeof value == "function"
            ? new OverpassDateEvaluatorImp(new OverpassRawEvaluatorNode(value))
            : OverpassDateEvaluatorImp.From(value);
    }
    boolean(value) {
        return typeof value == "function"
            ? new OverpassBooleanEvaluatorImp(new OverpassRawEvaluatorNode(value))
            : OverpassBooleanEvaluatorImp.From(value);
    }
}

class OverpassItemEvaluatorCountBuilderImp {
    tags() {
        return new OverpassNumberEvaluatorImp(new OverpassCountTagsEvaluatorNode());
    }
    members() {
        return new OverpassNumberEvaluatorImp(new OverpassCountMembersEvaluatorNode());
    }
    membersDistinct() {
        return new OverpassNumberEvaluatorImp(new OverpassCountMembersDistinctEvaluatorNode());
    }
    byRole(role) {
        return new OverpassNumberEvaluatorImp(new OverpassCountByRoleEvaluatorNode(OverpassStringEvaluatorImp.From(role)));
    }
    byRoleDistinct(role) {
        return new OverpassNumberEvaluatorImp(new OverpassCountByRoleDistinctEvaluatorNode(OverpassStringEvaluatorImp.From(role)));
    }
}
class OverpassItemEvaluatorBuilderImp extends OverpassEvaluatorBuilderImp {
    constructor() {
        super();
        this.count = new OverpassItemEvaluatorCountBuilderImp();
    }
    id() {
        return new OverpassNumberEvaluatorImp(new OverpassElementIdEvaluatorNode());
    }
    type() {
        return new OverpassStringEvaluatorImp(new OverpassElementTypeEvaluatorNode());
    }
    hasTag(tag) {
        return new OverpassBooleanEvaluatorImp(new OverpassElementHasTypeEvaluatorNode(tag));
    }
    getTag(tag) {
        return new OverpassStringEvaluatorImp(new OverpassElementGetTypeEvaluatorNode(tag));
    }
}

class OverpassTagFilterHelperBase {
    constructor(negated) {
        this.negated = negated;
    }
    not() {
        return this.clone(!this.negated);
    }
}

class OverpassEqualsTagFilter {
    constructor(prop, value, negated) {
        this.prop = prop;
        this.value = value;
        this.negated = negated;
    }
    compile(u) {
        const op = u.raw(this.negated ? "!=" : "=");
        return u.template `[${u.qString(this.prop)}${op}${u.qString(this.value)}]`;
    }
}

class OverpassExistsTagFilter {
    constructor(prop, negated) {
        this.prop = prop;
        this.negated = negated;
    }
    compile(u) {
        const prop = u.qString(this.prop);
        return this.negated ? u.template `[!${prop}]` : u.template `[${prop}]`;
    }
}

class OverpassRegExpTagFilter {
    constructor(prop, regExp, negated) {
        this.prop = prop;
        this.regExp = regExp;
        this.negated = negated;
    }
    getProp(u) {
        if (this.prop instanceof RegExp || (this.prop instanceof ParamItem && this.prop.isType(ParamType.RegExp))) {
            return u.template `~${u.regExp(this.prop)}`;
        }
        else {
            return u.qString(this.prop);
        }
    }
    compile(u) {
        const op = u.raw(this.negated ? "!~" : "~");
        return u.template `[${this.getProp(u)}${op}${u.regExp(this.regExp)}]`;
    }
}

class OverpassEqualsTagFilterHelper extends OverpassTagFilterHelperBase {
    constructor(value, negated) {
        super(negated);
        this.value = value;
    }
    clone(negated) {
        return new OverpassEqualsTagFilterHelper(this.value, negated);
    }
    complete(prop) {
        return new OverpassEqualsTagFilter(prop, this.value, this.negated);
    }
}

class OverpassExistsTagFilterHelper extends OverpassTagFilterHelperBase {
    constructor(negated) {
        super(negated);
    }
    clone(negated) {
        return new OverpassExistsTagFilterHelper(negated);
    }
    complete(prop) {
        return new OverpassExistsTagFilter(prop, this.negated);
    }
}

class OverpassRegExpTagFilterHelper extends OverpassTagFilterHelperBase {
    constructor(regExp, negated) {
        super(negated);
        this.regExp = regExp;
    }
    clone(negated) {
        return new OverpassRegExpTagFilterHelper(this.regExp, negated);
    }
    complete(prop) {
        return new OverpassRegExpTagFilter(prop, this.regExp, this.negated);
    }
}

class OverpassTagFilterBuilderImp {
    static Build() {
        return new OverpassTagFilterBuilderImp(false);
    }
    constructor(negated, opposite) {
        this.negated = negated;
        this.not = opposite !== null && opposite !== void 0 ? opposite : new OverpassTagFilterBuilderImp(!this.negated, this);
    }
    equals(value) {
        return new OverpassEqualsTagFilterHelper(value, this.negated);
    }
    exists() {
        return new OverpassExistsTagFilterHelper(this.negated);
    }
    regExp(exp) {
        return new OverpassRegExpTagFilterHelper(exp, this.negated);
    }
}

var _a;
class OverpassStatusValidatorImp {
    constructor(statusUrl, rejectOnUnexpected = false) {
        this.statusUrl = statusUrl;
        this.rejectOnUnexpected = rejectOnUnexpected;
    }
    static ConnectedAs(status, value) {
        status.connectedAs = +value;
    }
    static CurrentTime(status, value) {
        status.currentTime = new Date(value);
    }
    static AnnouncedEndpoint(status, value) {
        if (value != "none") {
            status.announcedEndpoint = value;
        }
    }
    static RateLimit(status, value) {
        status.ratelimit = +value;
    }
    static CurrentlyRunningQueries(status, line, state) {
        const parts = line
            .slice(line.indexOf("(") + 1, -2)
            .split(",")
            .map((part) => part.trim());
        state.runningQueries = true;
        status.runningQueries = [];
        state.queryIndexes = {
            pid: parts.indexOf("pid"),
            spaceLimit: parts.indexOf("space limit"),
            timeLimit: parts.indexOf("time limit"),
            start: parts.indexOf("start time"),
        };
        state.queryPartsLen = parts.length;
    }
    static SlotsAviable(status, line, state, regExp) {
        const [_, slots] = line.match(regExp);
        status.aviableSlots = +slots;
    }
    static RunningQueryItem(status, line, state) {
        const queryParts = line.split("\t");
        if (queryParts.length != state.queryPartsLen) {
            state.runningQueries = false;
        }
        else {
            const { pid, spaceLimit, timeLimit, start } = state.queryIndexes;
            status.runningQueries.push({
                pid: +queryParts[pid],
                spaceLimit: +queryParts[spaceLimit],
                timeLimit: +queryParts[timeLimit],
                start: new Date(queryParts[start]),
            });
        }
    }
    static GetPropHandlers() {
        return new Map([
            ["Connected as", this.ConnectedAs],
            ["Current time", this.CurrentTime],
            ["Announced endpoint", this.AnnouncedEndpoint],
            ["Rate limit", this.RateLimit],
        ]);
    }
    static GetRegExpHandlers() {
        return [
            { regExp: /^Currently running queries/, handle: this.CurrentlyRunningQueries },
            { regExp: /^(\d+) slots available now.$/, handle: this.SlotsAviable },
        ];
    }
    validateStatusResponse({ status, contentType, response }) {
        if (status != 200 || !(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith("text/plain"))) {
            throw new OverpassApiError(OverpassErrorType.UnknownError, status, this.statusUrl, undefined, {
                cause: response,
            });
        }
    }
    validate(response) {
        this.validateStatusResponse(response);
        const status = {
            aviableSlots: Infinity,
        };
        const state = {
            runningQueries: false,
            queryIndexes: undefined,
            queryPartsLen: -1,
        };
        response.response.split("\n").forEach((line) => {
            if (line == "")
                return;
            if (state.runningQueries) {
                OverpassStatusValidatorImp.RunningQueryItem(status, line, state);
            }
            if (!state.runningQueries) {
                const colon = line.indexOf(":");
                const prop = line.substring(0, colon).trim();
                if (OverpassStatusValidatorImp.PROP_HANDLERS.has(prop)) {
                    const value = line.substring(colon + 1).trim();
                    OverpassStatusValidatorImp.PROP_HANDLERS.get(prop)(status, value);
                }
                else {
                    const handler = OverpassStatusValidatorImp.REGEXP_HANDLERS.find(({ regExp }) => regExp.test(line));
                    if (handler != null) {
                        handler.handle(status, line, state, handler.regExp);
                    }
                    else if (this.rejectOnUnexpected) {
                        throw new Error(`Unexpected line from overpass status\n${line}`);
                    }
                }
            }
        });
        return status;
    }
}
_a = OverpassStatusValidatorImp;
OverpassStatusValidatorImp.PROP_HANDLERS = _a.GetPropHandlers();
OverpassStatusValidatorImp.REGEXP_HANDLERS = _a.GetRegExpHandlers();

const REMARK_MATCHERS = [
    {
        regExp: /runtime error: open64: \d+ Success \/osm3s_osm_base Dispatcher_Client::request_read_and_idx::duplicate_query/,
        type: OverpassErrorType.DuplicateQuery,
    },
    {
        regExp: /runtime error: Query timed out in "[\w-]+" at line \d+ after \d+ seconds\./,
        type: OverpassErrorType.QueryTimeout,
    },
    {
        regExp: /runtime error: Query ran out of memory in "[\w-]+" at line \d+. It would need at least [\d.,]+ MB of RAM to continue\./,
        type: OverpassErrorType.MemoryExhaustionError,
    },
    {
        regExp: /runtime error: Tried to use museum file but no museum files available on this instance\./,
        type: OverpassErrorType.NoAtticData,
    },
    {
        regExp: /runtime error: open64: \d+ No such file or directory \/db\/db\/relations_attic.map Random_File:\d+/,
        type: OverpassErrorType.NoAtticData,
    },
];
class OverpassQueryValidatorImp {
    constructor(interpreterUrl) {
        this.interpreterUrl = interpreterUrl;
    }
    parseErrorsFromHtml(htmlResponse) {
        return htmlResponse
            .split("</strong>")
            .slice(1)
            .map((errorStr) => {
            const error = errorStr.substring(0, errorStr.indexOf("</p>"));
            const lineError = error.split("\n").join(" ").split("<br>").join(" ").trim();
            return lineError.startsWith(":") ? lineError.slice(1).trim() : lineError;
        });
    }
    validateHttpResponse(httpCode, overpassQuery, response, responseType) {
        if (httpCode != 200 || responseType == null) {
            let message;
            if (responseType === null || responseType === void 0 ? void 0 : responseType.startsWith("text/html")) {
                message = this.parseErrorsFromHtml(response).join("\n");
            }
            else {
                message = response;
            }
            const reqParams = [httpCode, this.interpreterUrl, overpassQuery];
            switch (httpCode) {
                case 400:
                    throw new OverpassQueryError(OverpassErrorType.QueryError, ...reqParams, message);
                case 429:
                    throw new OverpassQueryError(OverpassErrorType.TooManyRequests, ...reqParams);
                default:
                    if (httpCode >= 500) {
                        throw new OverpassQueryError(OverpassErrorType.ServerError, ...reqParams, message);
                    }
                    else {
                        throw new OverpassQueryError(OverpassErrorType.UnknownError, ...reqParams, message);
                    }
            }
        }
        else if (responseType.startsWith("text/html")) {
            const errors = this.parseErrorsFromHtml(response);
            const type = errors.reduce((acc, error) => { var _a, _b; return (_b = (_a = REMARK_MATCHERS.find(({ regExp }) => regExp.test(error))) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : acc; }, null);
            throw new OverpassRemarkError(type !== null && type !== void 0 ? type : OverpassErrorType.QueryError, overpassQuery, errors);
        }
    }
    throwRemark(query, remark, remarks) {
        REMARK_MATCHERS.forEach(({ regExp, type }) => {
            if (regExp.test(remark)) {
                throw new OverpassRemarkError(type, query, remarks);
            }
        });
        throw new OverpassRemarkError(OverpassErrorType.QueryError, query, remarks);
    }
    validateJson(query, { remark }) {
        if (remark != null) {
            this.throwRemark(query, remark, [remark]);
        }
    }
    parseErrorsFromXML(xmlResponse) {
        return xmlResponse
            .split("<remark>")
            .slice(1)
            .map((errorStr) => errorStr.substring(0, errorStr.indexOf("</remark>")).trim());
    }
    validateXML(query, xml) {
        const remarks = this.parseErrorsFromXML(xml);
        if (remarks.length > 0) {
            this.throwRemark(query, remarks[0], remarks);
        }
    }
    validate(query, { status, response, contentType }, format) {
        this.validateHttpResponse(status, query, response, contentType);
        switch (format) {
            case OverpassFormat.JSON: {
                const parsed = JSON.parse(response);
                this.validateJson(query, parsed);
                return parsed;
            }
            case OverpassFormat.XML: {
                this.validateXML(query, response);
                return response;
            }
            default:
                return response;
        }
    }
}

function GetSanitizer(sanitization) {
    if (!sanitization) {
        return new NoOverpassStringSanitizer();
    }
    else if (sanitization === true) {
        return new NaiveOverpassStringSanitizer();
    }
    else {
        return sanitization;
    }
}
function BuildOverpassApi(adapter, optionsOrUrl, statusUrl) {
    if (typeof optionsOrUrl == "string" || optionsOrUrl instanceof URL) {
        console.warn("Building overpass api without OverpassApiObjectOptions has been deprecated since 1.8.1");
        console.warn("Will be removed on 2.x.x, use with OverpassApiObjectOptions");
        return PrivateBuildOverPassApi(adapter, { interpreterUrl: optionsOrUrl, statusUrl: statusUrl });
    }
    else {
        return PrivateBuildOverPassApi(adapter, optionsOrUrl !== null && optionsOrUrl !== void 0 ? optionsOrUrl : {});
    }
}
function PrivateBuildOverPassApi(adapter, options) {
    const interpreterUrl = InterpreterUrlFrom(options.interpreterUrl);
    const statusUrl = StatusUrlFrom(interpreterUrl, options.statusUrl);
    const queryValidator = new OverpassQueryValidatorImp(interpreterUrl);
    const statusValidator = new OverpassStatusValidatorImp(statusUrl);
    const sanitizer = GetSanitizer(options.sanitization);
    const compileUtils = new OverpassCompileUtils(sanitizer);
    const tagBuilder = OverpassTagFilterBuilderImp.Build();
    const evaluatorItemBuilder = new OverpassItemEvaluatorBuilderImp();
    return new OverpassApiObjectImp(adapter, interpreterUrl, statusUrl, queryValidator, statusValidator, compileUtils, tagBuilder, evaluatorItemBuilder);
}
function InterpreterUrlFrom(interpreterUrlInput) {
    return typeof interpreterUrlInput == "string"
        ? new URL(interpreterUrlInput)
        : interpreterUrlInput !== null && interpreterUrlInput !== void 0 ? interpreterUrlInput : OverpassApiObjectImp.MAIN_INSTANCE;
}
function StatusUrlFrom(interpreterUrl, statusUrl) {
    return typeof statusUrl == "string" ? new URL(statusUrl) : statusUrl !== null && statusUrl !== void 0 ? statusUrl : StatusUrlFromInterpreterUrl(interpreterUrl);
}
function StatusUrlFromInterpreterUrl(interpreterUrl) {
    const statusUrl = new URL(interpreterUrl);
    const parts = statusUrl.pathname.split("/").filter((part) => part != "");
    if (parts.slice(-2).join("/") != "api/interpreter") {
        throw new Error(`You should provide a status url for non standard interpreter ${interpreterUrl}`);
    }
    statusUrl.pathname = [...parts.slice(0, -1), "status"].join("/");
    return statusUrl;
}
OverpassApiObjectImp.BuildDeprecated = BuildOverpassApi;
OverpassApiObjectImp.InterpreterUrlFromDeprecated = InterpreterUrlFrom;
OverpassApiObjectImp.StatusUrlFromDeprecated = StatusUrlFrom;
OverpassApiObjectImp.StatusUrlFromInterpreterUrlDeprecated = StatusUrlFromInterpreterUrl;

const METHOD = enumObjectToArray({
    [HttpMethod.Get]: "GET",
    [HttpMethod.Post]: "POST",
});
function NetworkError(error) {
    return new OverpassError(OverpassErrorType.NetworkError, "Network error", { cause: error });
}

function FetchOverpassApi(optionsOrUrl, statusUrl) {
    return BuildOverpassApi(new FetchRequestAdapter(), optionsOrUrl, statusUrl);
}
class FetchRequestAdapter {
    constructor(fetchFn) {
        this.fetchFn = fetchFn !== null && fetchFn !== void 0 ? fetchFn : globalThis.fetch.bind(globalThis);
    }
    async request(url, { method, body } = {}) {
        try {
            const response = await this.fetchFn(url, {
                method: METHOD[method !== null && method !== void 0 ? method : HttpMethod.Get],
                body: body,
            });
            const text = await response.text();
            return {
                status: response.status,
                response: text,
                contentType: response.headers.get("Content-type"),
            };
        }
        catch (error) {
            throw NetworkError(error);
        }
    }
}

function HttpOverpassApi(optionsOrUrl, statusUrl) {
    return BuildOverpassApi(new NodeHttpRequestAdapter(), optionsOrUrl, statusUrl);
}
class NodeHttpRequestAdapter {
    constructor(methods) {
        this.loaded = false;
        if (methods != null) {
            [this.httpRequest, this.httpsRequest] = methods;
            this.loaded = true;
        }
        else if (!NodeHttpRequestAdapter.Loaded) {
            NodeHttpRequestAdapter.EnsureLoading();
        }
        else {
            [this.httpRequest, this.httpsRequest] = NodeHttpRequestAdapter.Methods;
            this.loaded = true;
        }
    }
    static EnsureLoading() {
        if (NodeHttpRequestAdapter.LoadPromise == null) {
            NodeHttpRequestAdapter.LoadPromise = NodeHttpRequestAdapter.Load();
        }
    }
    static async Load() {
        const [http, https] = await Promise.all([import('http'), import('https')]);
        this.Methods = [http.request, https.request];
        this.Loaded = true;
        delete this.LoadPromise;
    }
    request(url, request = {}) {
        if (this.loaded) {
            return this.doRequest(url, request);
        }
        else {
            return NodeHttpRequestAdapter.LoadPromise.then(() => {
                [this.httpRequest, this.httpsRequest] = NodeHttpRequestAdapter.Methods;
                this.loaded = true;
                return this.doRequest(url, request);
            });
        }
    }
    doRequest(url, { method, body }) {
        const requestMethod = url.protocol == "https:" ? this.httpsRequest : this.httpRequest;
        return new Promise((resolve, reject) => {
            const request = requestMethod(url, { method: METHOD[method !== null && method !== void 0 ? method : HttpMethod.Get] });
            request.on("response", (response) => {
                let responseBody = "";
                response.on("data", (chunk) => (responseBody += chunk));
                response.on("end", () => {
                    if (response.statusCode == null || response.statusCode == 0) {
                        reject(NetworkError(responseBody));
                    }
                    else {
                        resolve({
                            contentType: response.headers["content-type"],
                            response: responseBody,
                            status: response.statusCode,
                        });
                    }
                });
            });
            request.on("error", (error) => reject(NetworkError(error)));
            if (body != null) {
                request.write(body);
            }
            request.end();
        });
    }
}
NodeHttpRequestAdapter.Loaded = false;

function XMLOverpassApi(optionsOrUrl, statusUrl) {
    return BuildOverpassApi(new XMLHttpRequestAdapter(), optionsOrUrl, statusUrl);
}
class XMLHttpRequestAdapter {
    constructor(XMLHttpRequest) {
        this.XMLHttpRequest = XMLHttpRequest !== null && XMLHttpRequest !== void 0 ? XMLHttpRequest : globalThis.XMLHttpRequest;
    }
    request(url, { method, body } = {}) {
        return new Promise((resolve, reject) => {
            const request = new this.XMLHttpRequest();
            request.open(METHOD[method !== null && method !== void 0 ? method : HttpMethod.Get], url, true);
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    if (request.status == 0) {
                        reject(NetworkError());
                    }
                    else {
                        resolve({
                            status: request.status,
                            contentType: request.getResponseHeader("content-type"),
                            response: request.responseText,
                        });
                    }
                }
            };
            request.onerror = (error) => reject(NetworkError(error));
            request.send(body);
        });
    }
}

function DefaultOverpassApi(optionsOrUrl, statusUrl) {
    if (globalThis.fetch != null) {
        return FetchOverpassApi(optionsOrUrl, statusUrl);
    }
    else if (globalThis.XMLHttpRequest != null) {
        return XMLOverpassApi(optionsOrUrl, statusUrl);
    }
    else {
        return HttpOverpassApi(optionsOrUrl, statusUrl);
    }
}

export { CSVField, DefaultOverpassApi, FetchOverpassApi, HttpMethod, HttpOverpassApi, OverpasComparissonOperator, OverpassApiError, OverpassApiObjectImp, OverpassArithmeticOperator, OverpassError, OverpassErrorType, OverpassFormat, OverpassOutputGeoInfo, OverpassOutputVerbosity, OverpassParameterError, OverpassQueryError, OverpassQueryTarget, OverpassRecurseStmType, OverpassRemarkError, OverpassSortOrder, ParamItem, ParamType, StringQuoteType, XMLOverpassApi };
