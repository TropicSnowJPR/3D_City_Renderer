declare enum HttpMethod {
    Get = 0,
    Post = 1
}
interface HttpRequest {
    readonly method?: HttpMethod;
    readonly body?: string;
}
interface HttpResponse {
    readonly status: number;
    readonly contentType?: string;
    readonly response: string;
}
interface RequestAdapter {
    request(url: URL, request?: HttpRequest): Promise<HttpResponse>;
}

/**
 * Node = 0x0001
 * Way = 0x0010
 * Relation = 0x0100
 * --------
 * NodeWay = 0x0011 ( Node | Way )
 * NodeRelation = 0x0101 ( Node | Relation )
 * WayRelation = 0x0110 ( Way | Relation )
 * NodeWayRelation = 0x0111 ( Node | Way | Relation )
 */
declare enum OverpassQueryTarget {
    Node = 1,
    Way = 2,
    /** Node | Way */
    NodeWay = 3,
    Relation = 4,
    /** Node | Relation */
    NodeRelation = 5,
    /** Way | Relation */
    WayRelation = 6,
    /** Node | Way | Relation */
    NodeWayRelation = 7,
    Area = 8,
    Derived = 9
}
/** Recurse standalone statements take an input set, and produce a result set */
declare enum OverpassRecurseStmType {
    /**
     * All ways that have a node which appears in the input set
     * All relations that have a node or way which appears in the input set
     * All relations that have a way which appears in the result set
     */
    Up = 0,
    /**
     * All nodes that are part of a way which appears in the input set
     * All nodes and ways that are members of a relation which appears in the input set
     * All nodes that are part of a way which appears in the result set
     */
    Down = 1,
    /**
     * Additional to {@link OverpassRecurseStmType.Up}, it continues to follow backlinks onto the found relations
     * until it contains all relations that point to an object in the input or result set.
     */
    UpRelations = 2,
    /**
     * Additional to {@link OverpassRecurseStmType.Down}, it continues to follow the membership links including nodes in ways
     * until for every object in its input or result set all the members of that object are in the result set as well.
     */
    DownRelations = 3
}
declare enum OverpassOutputVerbosity {
    /** Print only the ids of the elements in the set. */
    Ids = 0,
    /**
     * Print the minimum information necessary for geometry:
     *  - nodes: id and coordinates
     *  - ways: id and the ids of its member nodes
     *  - relations: id of the relation, and the id, type, and role of all of its members.
     */
    Geometry = 1,
    /**
     * Print all information necessary to use the data.
     * These are also tags for all elements and the roles for relation members.
     */
    Body = 2,
    /** Print only ids and tags for each element and not coordinates or members. */
    Tags = 3,
    /**
     * Print everything known about the elements.
     * Includes everything output by body for each OSM element, as well as the version,
     * changeset id, timestamp, and the user data of the user that last touched the object.
     * Derived elements' metadata attributes are also missing for derived elements.
     */
    Metadata = 4
}
declare enum OverpassOutputGeoInfo {
    /**
     * Add the full geometry to each object.
     * This adds coordinates to each node, to each node member of a way or relation,
     * and it adds a sequence of "nd" members with coordinates to all relations.
     */
    Geometry = 0,
    /**
     * Adds only the bounding box of each element to the element.
     * For nodes this is equivalent to geom. For ways it is the enclosing bounding box of all nodes.
     * For relations it is the enclosing bounding box of all node and way members, relations as members have no effect.
     */
    BoundingBox = 1,
    /**
     * This adds only the centre of the above mentioned bounding box to ways and relations.
     * Note: The center point is not guaranteed to lie inside the polygon (example).
     */
    Center = 2
}
declare enum OverpassSortOrder {
    /** Sort by object id */
    Ascending = 0,
    /**
     * Sort by quadtile index;
     * This is roughly geographical and significantly faster than order by ids
     * (derived elements generated by make or convert statements without any geometry will be grouped separately,
     * only sorted by id).
     */
    QuadtileIndex = 1
}

interface OverpassGeoPos {
    readonly lat: number;
    readonly lon: number;
}
type OverpassBoundingBox = [south: number, west: number, north: number, east: number];

declare enum ParamType {
    Number = 0,
    String = 1,
    RegExp = 2,
    BoundingBox = 3,
    GeoPos = 4,
    Date = 5,
    Boolean = 6,
    Target = 7,
    Verbosity = 8,
    GeoInfo = 9,
    SortOrder = 10,
    RecurseStm = 11
}
type EnumParamType = ParamType.Target | ParamType.Verbosity | ParamType.GeoInfo | ParamType.SortOrder | ParamType.RecurseStm;
type OverpassEnum = OverpassQueryTarget | OverpassOutputVerbosity | OverpassOutputGeoInfo | OverpassSortOrder | OverpassRecurseStmType;
type AnyParamValue = number | boolean | OverpassEnum | string | RegExp | Date | OverpassBoundingBox | OverpassGeoPos;
type ActualEnumParamType<T extends OverpassEnum> = T extends OverpassQueryTarget ? ParamType.Target : T extends OverpassOutputVerbosity ? ParamType.Verbosity : T extends OverpassOutputGeoInfo ? ParamType.GeoInfo : T extends OverpassSortOrder ? ParamType.SortOrder : T extends OverpassRecurseStmType ? ParamType.RecurseStm : never;
type ActualParamType<T> = T extends OverpassEnum ? ActualEnumParamType<T> | ParamType.Number : T extends number ? ParamType.Number : T extends boolean ? ParamType.Boolean : T extends string ? ParamType.String : T extends RegExp ? ParamType.RegExp : T extends Date ? ParamType.Date : T extends OverpassBoundingBox ? ParamType.BoundingBox : T extends OverpassGeoPos ? ParamType.GeoPos : never;
type ValueTypeFromParam = {
    [ParamType.Number]: number;
    [ParamType.String]: string;
    [ParamType.RegExp]: RegExp;
    [ParamType.BoundingBox]: OverpassBoundingBox;
    [ParamType.GeoPos]: OverpassGeoPos;
    [ParamType.Date]: Date;
    [ParamType.Boolean]: boolean;
    [ParamType.Target]: OverpassQueryTarget;
    [ParamType.Verbosity]: OverpassOutputVerbosity;
    [ParamType.GeoInfo]: OverpassOutputGeoInfo;
    [ParamType.SortOrder]: OverpassSortOrder;
    [ParamType.RecurseStm]: OverpassRecurseStmType;
};
declare class ParamItem<T> {
    readonly index: number;
    readonly type: ActualParamType<T>;
    constructor(index: number, type: ActualParamType<T>);
    isType<P extends ParamType>(type: P): this is ParamItem<ValueTypeFromParam[P]>;
}
type OverpassExpression<T> = T | ParamItem<T>;

interface CompiledItem<T> {
    /** Wether this item does not depend on a parameter */
    isSimplifiable(): boolean;
    /** Simplifies the expression, presumes {@link isSimplifiable()} to be true */
    simplify(): T;
    /** The expression will eventually yield a string */
    asString(): CompiledItem<string>;
    /** Eventually transforms the expression to a string using {@link callback} */
    transform(callback: (raw: T) => string): CompiledItem<string>;
    /** Resolve the expression value from a function parameters */
    resolve(params: any[]): T;
    /** Compiles the expression from a function parameters */
    compile(params: any[]): string;
}
type CompiledOverpassBoundingBox = [
    south: CompiledItem<number>,
    west: CompiledItem<number>,
    north: CompiledItem<number>,
    east: CompiledItem<number>
];
interface CompiledOverpassGeoPos {
    readonly lat: CompiledItem<number>;
    readonly lon: CompiledItem<number>;
}

interface CompilableItem {
    compile(utils: CompileUtils): CompiledItem<string>;
}
interface CompileUtils {
    readonly nl: CompiledItem<string>;
    /**
     * @param value A string that should be sanitized
     * @returns the prepared string with quotes included
     */
    qString(value: OverpassExpression<string>): CompiledItem<string>;
    /** @param value A number that should be sanitized */
    number(value: OverpassExpression<number>): CompiledItem<number>;
    /** @param value A regexp that should be prepared */
    regExp(value: OverpassExpression<RegExp>): CompiledItem<RegExp>;
    date(value: OverpassExpression<Date>): CompiledItem<Date>;
    /**
     * @param value A bbox that should be prepared
     * @returns the respective prepared parts [s, w, n, e]
     */
    bbox(value: OverpassExpression<OverpassBoundingBox>): CompiledOverpassBoundingBox;
    /**
     * @param value A geo pos that should be prepared
     * @returns the respective prepared parts { lat, lon }
     */
    geoPos(value: OverpassExpression<OverpassGeoPos>): CompiledOverpassGeoPos;
    /** @param value A set name */
    set(value: OverpassExpression<string>): CompiledItem<string>;
    /** @param value A boolean value for use inside an evaluator */
    boolean(value: OverpassExpression<boolean>): CompiledItem<boolean>;
    /** @param value A target that should be prepared */
    target(value: OverpassExpression<OverpassQueryTarget>): CompiledItem<OverpassQueryTarget>;
    /** @param value A verbosity that should be prepared */
    verbosity(value: OverpassExpression<OverpassOutputVerbosity>): CompiledItem<OverpassOutputVerbosity>;
    /** @param value A geoInfo that should be prepared */
    geoInfo(value: OverpassExpression<OverpassOutputGeoInfo>): CompiledItem<OverpassOutputGeoInfo>;
    /** @param value A sortOrder that should be prepared */
    sortOrder(value: OverpassExpression<OverpassSortOrder>): CompiledItem<OverpassSortOrder>;
    /** @param value A recurse type that should be prepared */
    recurse(value: OverpassExpression<OverpassRecurseStmType>): CompiledItem<OverpassRecurseStmType>;
    /** A string that should ve used as is */
    raw(string: string): CompiledItem<string>;
    /** Join several expressions into one */
    join(expressions: CompiledItem<any>[], separator: string): CompiledItem<string>;
    /**
     * Build an item with a template using other expressions
     * @example
     * 	u.template`node(${u.number(id)})`
     */
    template(strings: TemplateStringsArray, ...expr: CompiledItem<any>[]): CompiledItem<string>;
}
type CompileFunction = (utils: CompileUtils) => CompiledItem<any>;

type OverpassEvaluatorExpression<T> = OverpassExpression<T> | OverpassEvaluator<T>;
interface OverpassEvaluatorNode<T> extends CompilableItem {
    /** Just for typing prupposes */
    readonly _$?: T | undefined;
    compile(utils: CompileUtils): CompiledItem<string>;
}
interface OverpassEvaluator<T> extends CompilableItem {
    readonly node: OverpassEvaluatorNode<T>;
    eq(evaluator: OverpassEvaluatorExpression<T>): OverpassBooleanEvaluator;
    neq(evaluator: OverpassEvaluatorExpression<T>): OverpassBooleanEvaluator;
    with(node: OverpassEvaluatorNode<T>): OverpassEvaluator<T>;
}

interface OverpassBooleanEvaluatorThen<T, E extends OverpassEvaluator<T>> {
    else(evaluator: E): E;
}
interface OverpassBooleanEvaluator extends OverpassEvaluator<boolean> {
    not(): OverpassBooleanEvaluator;
    or(...conditions: OverpassEvaluatorExpression<boolean>[]): OverpassBooleanEvaluator;
    and(...conditions: OverpassEvaluatorExpression<boolean>[]): OverpassBooleanEvaluator;
    conditional<T, E extends OverpassEvaluator<T>>(ifTrue: E, ifFalse: E): E;
    then<T, E extends OverpassEvaluator<T>>(evaluator: E): OverpassBooleanEvaluatorThen<T, E>;
}

declare enum OverpasComparissonOperator {
    Lower = 0,
    LowerOrEquals = 1,
    GreaterOrEquals = 2,
    Greater = 3
}
interface OverpassMagnitudeEvaluator<T extends number | Date> extends OverpassEvaluator<T> {
    compare(op: OverpasComparissonOperator, right: OverpassEvaluatorExpression<T>): OverpassBooleanEvaluator;
    lt(right: OverpassEvaluatorExpression<T>): OverpassBooleanEvaluator;
    le(right: OverpassEvaluatorExpression<T>): OverpassBooleanEvaluator;
    ge(right: OverpassEvaluatorExpression<T>): OverpassBooleanEvaluator;
    gt(right: OverpassEvaluatorExpression<T>): OverpassBooleanEvaluator;
}

interface OverpassDateEvaluator extends OverpassMagnitudeEvaluator<Date> {
}

declare enum OverpassArithmeticOperator {
    Add = 0,
    Sub = 1,
    Mult = 2,
    Divide = 3
}
interface OverpassNumberEvaluator extends OverpassMagnitudeEvaluator<number> {
    abs(): OverpassNumberEvaluator;
    op(op: OverpassArithmeticOperator, number: OverpassEvaluatorExpression<number>): OverpassNumberEvaluator;
    plus(number: OverpassEvaluatorExpression<number>): OverpassNumberEvaluator;
    minus(number: OverpassEvaluatorExpression<number>): OverpassNumberEvaluator;
    times(number: OverpassEvaluatorExpression<number>): OverpassNumberEvaluator;
    dividedBy(number: OverpassEvaluatorExpression<number>): OverpassNumberEvaluator;
}

interface OverpassStringEvaluator extends OverpassEvaluator<string> {
    isNumber(): OverpassBooleanEvaluator;
    parseNumber(): OverpassNumberEvaluator;
    isDate(): OverpassBooleanEvaluator;
    parseDate(): OverpassDateEvaluator;
    asBool(): OverpassBooleanEvaluator;
}

interface OverpassTagFilter extends CompilableItem {
}

interface OverpassStatement extends CompilableItem {
}
interface ComposableOverpassStatement extends OverpassStatement {
    /** Join the elements of the current statement with those of {@link statement} */
    union(statement: ComposableOverpassStatement): ComposableOverpassStatement;
    /** Keep the elements that are in the current statement, but not in {@link statement} */
    difference(statement: ComposableOverpassStatement): ComposableOverpassStatement;
    /** Saves the current statement to {@link set} */
    toSet(set: OverpassExpression<string>): ComposableOverpassStatement;
}
interface ChainableOverpassStatement extends ComposableOverpassStatement {
    compileChainable(utils: CompileUtils): CompiledItem<string>[];
}
interface OverpassStatementTarget extends CompilableItem {
    withIntersection(set1: OverpassExpression<string>, ...sets: OverpassExpression<string>[]): OverpassStatementTarget;
}

interface OverpassEvaluatorBuilder {
    readonly true: OverpassBooleanEvaluator;
    readonly false: OverpassBooleanEvaluator;
    conditional<T, E extends OverpassEvaluator<T>>(condition: OverpassEvaluatorExpression<boolean>, ifTrue: E, ifFalse: E): E;
    or(condition: OverpassEvaluatorExpression<boolean>, ...conditions: OverpassEvaluatorExpression<boolean>[]): OverpassBooleanEvaluator;
    and(condition: OverpassEvaluatorExpression<boolean>, ...conditions: OverpassEvaluatorExpression<boolean>[]): OverpassBooleanEvaluator;
    number(value: OverpassExpression<number> | CompileFunction): OverpassNumberEvaluator;
    string(value: OverpassExpression<string> | CompileFunction): OverpassStringEvaluator;
    date(value: OverpassExpression<Date> | CompileFunction): OverpassDateEvaluator;
    boolean(value: OverpassExpression<boolean> | CompileFunction): OverpassBooleanEvaluator;
}
interface OverpassItemEvaluatorBuilder extends OverpassEvaluatorBuilder {
    id(): OverpassNumberEvaluator;
    type(): OverpassStringEvaluator;
    hasTag(tag: OverpassExpression<string>): OverpassBooleanEvaluator;
    getTag(tag: OverpassExpression<string>): OverpassStringEvaluator;
    readonly count: OverpassItemEvaluatorCountBuilder;
}
interface OverpassItemEvaluatorCountBuilder {
    tags(): OverpassNumberEvaluator;
    members(): OverpassNumberEvaluator;
    membersDistinct(): OverpassNumberEvaluator;
    byRole(role: OverpassEvaluatorExpression<string>): OverpassNumberEvaluator;
    byRoleDistinct(role: OverpassEvaluatorExpression<string>): OverpassNumberEvaluator;
}

interface OverpassOutputOptions {
    /** Target set to output.
     * Default is _
     */
    readonly targetSet?: OverpassExpression<string>;
    /**
     * Degree of verbosity of the output.
     * Default is @see {OverpassOutputVerbosity.Body}
     */
    readonly verbosity?: OverpassExpression<OverpassOutputVerbosity>;
    /**
     * Amount of geolocated information.
     * Default is none
     */
    readonly geoInfo?: OverpassExpression<OverpassOutputGeoInfo>;
    /**
     * Only elements whose coordinates are inside this bounding box are produced.
     * For way segments,
     * the first or last coordinates outside this bounding box are also produced to allow for properly formed segment
     * (this restriction has no effect on derived elements without any geometry).
     */
    readonly boundingBox?: OverpassExpression<OverpassBoundingBox>;
    readonly sortOrder?: OverpassExpression<OverpassSortOrder>;
    /** A non-negative integer, which limits the output to a maximum of the given number. */
    readonly limit?: OverpassExpression<number>;
    /** Wheter to not include an out at the end of a query, only works on top level options */
    readonly noGlobalOut?: OverpassExpression<boolean>;
}

declare enum OverpassFormat {
    XML = 0,
    /** The output will be parsed */
    JSON = 1,
    /** The output will not be parsed */
    JSONText = 2,
    /** Additional configuration needed @see OverpassCSVSettings.csvSettings */
    CSV = 3,
    /** HTML document with list containing maps */
    Custom = 4,
    Popup = 5
}
interface OverpassSettingsBase<F extends OverpassFormat> {
    /**
     * Non-negative integer. Default value is 180.
     * This parameter indicates the maximum allowed runtime for the query in seconds, as expected by the user.
     * If the query runs longer than this time, the server may abort the query with a timeout.
     * The second effect is, the higher this value, the more probably the server rejects the query before executing it.
     * So, if you send a really complex big query, prefix it with a higher value; e.g., "3600" for an hour.
     * And ensure that your client is patient enough to not abort due to a timeout in itself.
     */
    readonly timeout?: OverpassExpression<number>;
    /**
     * Non-negative integer. Default value is 536870912 (512 MB).
     * This parameter indicates the maximum allowed memory for the query in bytes RAM on the server, as expected by the user.
     * If the query needs more RAM than this value, the server may abort the query with a memory exhaustion.
     * The second effect is, the higher this value, the more probably the server rejects the query before executing it.
     * So, if you send a really complex big query, prefix it with a higher value; e.g., "1073741824" for a gigabyte.
     * The maximum value highly depends on the current server load,
     * e.g. requests for 2GB will likely be rejected during peak hours, as they don't fit into the overall resource management.
     * Technically speaking, maxsize is treated as a 64bit signed number.
     */
    readonly maxSize?: OverpassExpression<number>;
    /** The output format used to return OSM data. Default is {@link OverpassFormat.XML}. */
    readonly format?: F;
    /**
     * The global bbox setting can be used to define a bounding box and then this is implicitly used in all statements
     * (unless a statement specifies a different explicit bbox).
     * If no bbox is specified the default value is "the entire world".
     * In a standard Overpass QL program,
     * a bounding box is constructed with two decimal degree coordinate pairs in ISO 6709 standard order and format,
     * and each value is separated with a comma.
     * The values are, in order: southern-most latitude, western-most longitude, northern-most latitude, eastern-most longitude.
     */
    readonly globalBoundingBox?: OverpassExpression<OverpassBoundingBox>;
    /**
     * Attic: OSM data that is no longer valid in an up-to-date dataset
     * Modifies an Overpass QL query to examine attic data,
     * and return results based on the OpenStreetMap database as of the date specified.
     * This setting can be useful, for example, to reconstruct data that has been vandalized,
     * or simply to view an object as it existed in the database at some point in the past.
     */
    readonly date?: OverpassExpression<Date>;
    /**
     * The diff setting lets the database determine the difference of two queries at different points in time.
     * This is useful for example to deltas for database extracts.
     * If only one date is supplied, the second date defaults to "now".
     */
    readonly diff?: OverpassExpression<Date> | [OverpassExpression<Date>, OverpassExpression<Date>];
}
declare enum CSVField {
    Id = 0,
    Type = 1,
    OType = 2,
    Latitude = 3,
    Longitude = 4,
    /**
     * The following meta information fields are only available if out meta;
     * Is used to output OSM elements.
     */
    Version = 5,
    Timestamp = 6,
    Changeset = 7,
    UserId = 8,
    UserName = 9,
    /**
     * The following meta information fields are only available if out count;
     * Is used to output OSM elements.
     */
    Count = 10,
    NodeCount = 11,
    WayCount = 12,
    RelationCount = 13,
    AreaCount = 14
}
type AnyCSVField = CSVField | string;
interface OverpassCSVFormatSettings {
    /**
     * The fields you want extracted, must be at least one
     * You can extract tag fields (ie: "name") and special metadata from the element.
     * Special fields need to be prefied with :: (ie: ::id), or used via @see CSVField
     */
    readonly fields: [AnyCSVField, ...AnyCSVField[]];
    /** Wether to include a header line. Default is true */
    readonly headerLine?: boolean;
    /** Separator between columns. Default is Tab (â†¹) */
    readonly delimiterCharacter?: string;
}
interface OverpassCSVSettings extends OverpassSettingsBase<OverpassFormat.CSV> {
    /** When {@link format} is {@link OverpassFormat.CSV}, additional csv options */
    readonly csvSettings: OverpassCSVFormatSettings;
}
type OverpassSettings = OverpassSettingsBase<Exclude<OverpassFormat, OverpassFormat.CSV>> | OverpassCSVSettings;

interface OverpassElementBounds {
    readonly minlat: number;
    readonly minlon: number;
    readonly maxlat: number;
    readonly maxlon: number;
}
type OverpassBasicElementType = "node" | "way" | "relation";
type OverpassElementType = OverpassBasicElementType | "area" | "timeline" | "count";
interface OverpassElement<T extends OverpassElementType> {
    readonly id: number;
    readonly type: T;
}
interface OverpassOsmElement<T extends OverpassElementType> extends OverpassElement<T> {
    readonly timestamp?: string;
    readonly version?: number;
    readonly changeset?: number;
    readonly user?: string;
    readonly uid?: number;
    readonly tags?: {
        [key: string]: string;
    };
}
interface OverpassNode extends OverpassOsmElement<"node"> {
    readonly lat: number;
    readonly lon: number;
}
interface OverpassWay extends OverpassOsmElement<"way"> {
    readonly nodes: number[];
    readonly center?: OverpassGeoPos;
    readonly bounds?: OverpassElementBounds;
    readonly geometry?: OverpassGeoPos[];
}
interface OverpassRelation extends OverpassOsmElement<"relation"> {
    readonly members: OverpassRelationMember[];
    readonly center?: OverpassGeoPos;
    readonly bounds?: OverpassElementBounds;
    readonly geometry?: OverpassGeoPos[];
}
interface OverpassRelationMember {
    readonly type: OverpassBasicElementType;
    readonly ref: number;
    readonly role: string;
    readonly lon?: number;
    readonly lat?: number;
    readonly geometry?: OverpassGeoPos[];
}
interface OverpassArea extends OverpassElement<"area"> {
    readonly tags: {
        [key: string]: string;
    };
}
interface OverpassTimeline extends OverpassElement<"timeline"> {
    readonly tags: {
        readonly reftype: string;
        readonly ref: string;
        readonly refversion: string;
        readonly created: string;
        readonly expired?: string;
    };
}
interface OverpassCount extends OverpassElement<"count"> {
    readonly tags: {
        readonly nodes: string;
        readonly ways: string;
        readonly relations: string;
        readonly total: string;
    };
}
type AnyOverpassElement = OverpassNode | OverpassWay | OverpassRelation | OverpassArea | OverpassTimeline | OverpassCount;
interface OverpassJsonOutput {
    readonly version: number;
    readonly generator: string;
    readonly osm3s: {
        readonly timestamp_osm_base: string;
        readonly timestamp_areas_base?: string;
        readonly copyright: string;
    };
    readonly remark?: string;
    readonly elements: AnyOverpassElement[];
}
type OverpassApiOutput<S extends OverpassSettings, O extends OverpassOutputOptions> = S["format"] extends OverpassFormat.JSON ? OverpassJsonOutput : string;

interface OverpassForEachItem {
    readonly name: OverpassExpression<string>;
}
type OverpassForEachBodyFunction = (item: OverpassForEachItem) => OverpassStatement[] | OverpassStatement;

interface OverpassTagFilterHelper {
    complete(prop: OverpassExpression<string | RegExp>): OverpassTagFilter;
    not(): OverpassTagFilterHelper;
}
interface OverpassTagFilterBuilder {
    readonly not: OverpassTagFilterBuilder;
    /** Prop is exactly {@link value} */
    equals(value: OverpassExpression<string>): OverpassTagFilterHelper;
    /** Prop is defined on the element */
    exists(): OverpassTagFilterHelper;
    /** Prop satisfies the following RegExp */
    regExp(exp: OverpassExpression<RegExp>): OverpassTagFilterHelper;
}
type AnyOverpassTagFilter = OverpassExpression<string> /** Prop is exactly this */ | OverpassExpression<RegExp> /** Prop satisfies the following this */ | OverpassTagFilterHelper /** Any tag filter */;
/**
 * An object representing the restrictions to be applied to a key
 * ie: { name: "Hello World" } => [name="Hello World"]
 * ie: { name: [/^Hello/, /World$/] } => [name~"^Hello"][name~"World$"]
 */
type OverpassQueryTagFitlerObject = Record<string, AnyOverpassTagFilter | AnyOverpassTagFilter[]>;
/**
 * A single regexp restriction to be aplied to some key
 * ie: [/^na.e$/, /^He.*ld$/] => [~"^na.e$"~"^He.*ld$"]
 */
type OverpassQueryRegExpTagFilterTuple = [OverpassExpression<RegExp>, OverpassExpression<RegExp>];
type OverpassQueryTagFilterTuple = [OverpassExpression<string>, AnyOverpassTagFilter]
/** A regular expression for a key can only be combined with a regular expression as value criterion */
 | OverpassQueryRegExpTagFilterTuple;
type OverpassQueryTagFilters = OverpassQueryTagFitlerObject | OverpassQueryTagFilterTuple[];
/** Helper function to build special filters */
type OverpassQueryTagFilterFunction = (builder: OverpassTagFilterBuilder) => OverpassQueryTagFilters;

type OverpassAnyString = "any";
type OverpassNodeString = "node";
type OverpassWayString = "way";
type OverpassRelationString = "relation";
type OverpassQueryTargetString = OverpassAnyString | OverpassNodeString | OverpassWayString | OverpassRelationString;
type AnyOverpassQueryTarget = OverpassQueryTarget | OverpassQueryTargetString;
type OverpassPositionLiteralExpression = [number, number] | OverpassExpression<OverpassGeoPos>;
type OverpassQueryTargetExpression = AnyOverpassQueryTarget | OverpassExpression<OverpassQueryTarget>;

type RecurseFromPrimitiveType = OverpassWayString | OverpassQueryTarget.Way | OverpassRelationString | OverpassQueryTarget.Relation;
type RecurseToPrimitiveType = OverpassNodeString | OverpassQueryTarget.Node | OverpassWayString | OverpassQueryTarget.Way;

interface AndChainableOverpassStatement {
    and(statement: ChainableOverpassStatement | ((chain: OverpassChainableTargetableState) => ChainableOverpassStatement)): OverpassTargetStateStatement;
}
type OverpassTargetStateStatement = AndChainableOverpassStatement & ComposableOverpassStatement;
interface OverpassRecurseFilterStatement extends OverpassTargetStateStatement {
    inSet(set: OverpassExpression<string>): OverpassRecurseFilterStatement;
    withRole(role: OverpassExpression<string>): OverpassRecurseFilterStatement;
    withoutRole(): OverpassRecurseFilterStatement;
}
interface OverpassTargetState {
    /**
     * The elements that satisfy {@link tagFilter}
     * @deprecated since 1.8.0, will be removed on 2.x.x, use {@link byTags}
     */
    query(tagFilter: OverpassQueryTagFilters | OverpassQueryTagFilterFunction): OverpassTargetStateStatement;
    /** The elements that satisfy {@link tagFilter} */
    byTags(tagFilter: OverpassQueryTagFilters | OverpassQueryTagFilterFunction): OverpassTargetStateStatement;
    /** The elements that are inside the bounding box */
    bbox(...params: OverpassBoundingBox): OverpassTargetStateStatement;
    bbox(bbox: OverpassExpression<OverpassBoundingBox>): OverpassTargetStateStatement;
    /** Fetch by {@link id} */
    byId(id: OverpassExpression<number> | OverpassExpression<number>[]): OverpassTargetStateStatement;
    /** The elements that are inside a {@link polygon} */
    inside(polygon: OverpassPositionLiteralExpression[]): OverpassTargetStateStatement;
    /** Those elements that satisfy {@link predicate} */
    filter(predicate: (e: OverpassItemEvaluatorBuilder) => OverpassEvaluator<boolean>): OverpassTargetStateStatement;
    /**
     * Those elements within a certain {@link radius} around the {@link center}
     * @param radius in meters
     */
    aroundCenter(radius: OverpassExpression<number>, center: OverpassExpression<OverpassGeoPos>): OverpassTargetStateStatement;
    /**
     * Those elements within a certain {@link radius} around the elements in the input {@link set}
     * @param radius in meters
     * @param set if unspecified asumes the default set
     */
    aroundSet(radius: OverpassExpression<number>, set?: OverpassExpression<string>): OverpassTargetStateStatement;
    /**
     * Those elements within a certain {@link radius} around the specified {@link line}
     * @param radius in meters
     */
    aroundLine(radius: OverpassExpression<number>, line: OverpassPositionLiteralExpression[]): OverpassTargetStateStatement;
    /**
     * Those elements that are inside the given area or areas in the specified {@link set}.
     * @param set if unspecified asumes the default set
     */
    inArea(set?: OverpassExpression<string>): OverpassTargetStateStatement;
    /**
     * The elements that defines the outline of the given areas specified in {@link set}
     * Does not work with nodes {@link OverpassQueryTarget.Node}
     * @param set if unspecified asumes the default set
     */
    pivot(set?: OverpassExpression<string>): OverpassTargetStateStatement;
    /**
     * Select child nodes, ways or relations from {@link type}
     * Relations have all types of elements.
     * Ways have nodes.
     * @param inSet wether to use a specific set for the source elements
     * @param withRole wether to filter elements from a relation of a specific role
     */
    recurseFrom(type: RecurseFromPrimitiveType | ParamItem<OverpassQueryTarget>, inSet?: OverpassExpression<string>, withRole?: string): OverpassRecurseFilterStatement;
    /**
     * Select parent ways or relations from {@link type}
     * Relations have all types of elements.
     * Ways have nodes.
     * @param inSet wether to use a specific set for the source elements
     * @param withRole wether to filter elements from a relation of a specific role
     */
    recurseBackwards(type: OverpassQueryTargetExpression, inSet?: OverpassExpression<string>, withRole?: string): OverpassRecurseFilterStatement;
}
/** Runs the statement for the specified {@link target} */
type OverpassTargetableState = {
    [K in keyof OverpassTargetState]: (target: OverpassQueryTargetExpression, ...args: Parameters<OverpassTargetState[K]>) => ReturnType<OverpassTargetState[K]>;
};
interface OverpassTargetMapState extends OverpassTargetState {
    /** Intersect many {@link sets} */
    intersect(set1: OverpassExpression<string>, ...sets: OverpassExpression<string>[]): ComposableOverpassStatement & OverpassTargetState;
}
/** Runs the statement for the selected key target @see AnyOverpassQueryTarget */
type OverpassTargetMap = {
    [K in AnyOverpassQueryTarget]: OverpassTargetMapState;
};
/** Returns a statement that can be chained */
type OverpassChainableTargetableState = {
    [K in keyof OverpassTargetState]: (...args: Parameters<OverpassTargetState[K]>) => ChainableOverpassStatement;
};
interface OverpassStateMethods {
    readonly chain: OverpassChainableTargetableState;
    /**
     * Fallback for things that are not currently implemented
     * Avoid using if possible
     */
    statement(statement: string): OverpassStatement;
    statement(compile: CompileFunction): OverpassStatement;
    /**
     * Fallback for things that are not currently implemented
     * Avoid using if possible
     * This statement is expected to be usable within unions and such.
     */
    composableStatement(statement: string): ComposableOverpassStatement;
    composableStatement(compile: CompileFunction): ComposableOverpassStatement;
    /** The contents of {@link set} */
    set(target: OverpassQueryTargetExpression, set: OverpassExpression<string>): ComposableOverpassStatement & OverpassTargetState;
    /** Intersect many {@link sets} */
    intersect(target: OverpassQueryTargetExpression, set1: OverpassExpression<string>, ...sets: OverpassExpression<string>[]): ComposableOverpassStatement & OverpassTargetState;
    recurse(type: OverpassExpression<OverpassRecurseStmType>, input?: OverpassExpression<string>): ComposableOverpassStatement;
    out(options: OverpassOutputOptions): OverpassStatement;
    /** Iterate over the elements of the default set */
    forEach(body: OverpassForEachBodyFunction): OverpassStatement;
    /** Iterate over the elements of {@link set} */
    forEach(set: OverpassExpression<string>, body: OverpassForEachBodyFunction): OverpassStatement;
    /**
     * Iterate over the elements of {@link set} with a variable for {@link item}
     * @param set if null uses the default set
     */
    forEach(set: OverpassExpression<string> | null, item: OverpassExpression<string>, body: OverpassForEachBodyFunction): OverpassStatement;
}
/**
 * This type helps with creation of statements
 *
 * @see OverpassTargetMap
 * @see OverpassTargetableState
 *
 * @example ```typescript
 *  (s: OverpassState) => [
 *      s.node.byId(1),
 *      s[OverpassQueryTarget.NodeWayRelation].byId(1),
 *      s.byId("way", 1),
 *      s.byId(OverpassQueryTarget.Relation, 1)
 *  ]
 * ```
 */
type OverpassState = OverpassTargetMap & OverpassTargetableState & OverpassStateMethods;

interface OverpassRunningQuery {
    readonly pid: number;
    readonly spaceLimit: number;
    readonly timeLimit: number;
    readonly start: Date;
}
interface OverpassStatus {
    readonly connectedAs: number;
    readonly currentTime: Date;
    readonly announcedEndpoint?: string;
    readonly ratelimit: number;
    readonly aviableSlots: number;
    readonly runningQueries: OverpassRunningQuery[];
}

type OverpassJsonSettings<S extends OverpassSettingsNoFormat> = S & {
    format: OverpassFormat.JSON;
};
type OverpassSettingsNoFormat = Omit<OverpassSettings, "format">;
type ArgTypes<Args extends AnyParamValue[]> = {
    [K in keyof Args]: ActualParamType<Args[K]>;
};
type CreateFunctionArgs<Args extends AnyParamValue[]> = {
    [K in keyof Args]: ParamItem<Args[K]>;
};
interface CreateFunctionContext<S extends OverpassSettingsNoFormat, O extends OverpassOutputOptions> {
    readonly statements: OverpassStatement[];
    readonly outpOptions?: O;
    readonly settings?: S;
}
type OverpassApiFunction<Args extends AnyParamValue[], S extends OverpassSettingsNoFormat, O extends OverpassOutputOptions> = (...args: Args) => Promise<OverpassApiOutput<OverpassJsonSettings<S>, O>>;
interface OverpassApiObject {
    /** Build a query string from a list of statements */
    buildQuery(statementBuilder: (state: OverpassState) => OverpassStatement[] | OverpassStatement, options?: OverpassOutputOptions, settings?: OverpassSettings): string;
    /** Execute a query with custom output format  */
    exec<S extends OverpassSettings, O extends OverpassOutputOptions>(settings: S, statementBuilder: (state: OverpassState) => OverpassStatement[] | OverpassStatement, options?: O): Promise<OverpassApiOutput<S, O>>;
    /** Execute a query with json output format */
    execJson<S extends OverpassSettingsNoFormat, O extends OverpassOutputOptions>(statementBuilder: (state: OverpassState) => OverpassStatement[] | OverpassStatement, options?: O, settings?: S): Promise<OverpassApiOutput<OverpassJsonSettings<S>, O>>;
    /** Executes a raw string query */
    execQuery(query: string | CompileFunction): Promise<OverpassJsonOutput | string>;
    /**
     * Creates a precompiled query that has some arguments
     * Settings & Options are static
     */
    createFunction<Args extends AnyParamValue[], S extends OverpassSettingsNoFormat, O extends OverpassOutputOptions>(argTypes: ArgTypes<Args>, statementBuilder: (state: OverpassState, ...args: CreateFunctionArgs<Args>) => OverpassStatement[] | OverpassStatement, options?: O, settings?: S): OverpassApiFunction<Args, S, O>;
    /**
     * Creates a precompiled query that has some arguments
     * Settings & Options are dynamic
     */
    createFunction<Args extends AnyParamValue[], S extends OverpassSettingsNoFormat, O extends OverpassOutputOptions>(argTypes: ArgTypes<Args>, statementBuilder: (state: OverpassState, ...args: CreateFunctionArgs<Args>) => CreateFunctionContext<S, O>): OverpassApiFunction<Args, S, O>;
    /** Fetches the overpass api instance status */
    status(): Promise<OverpassStatus>;
}

declare enum StringQuoteType {
    Single = "'",
    Double = "\""
}
interface OverpassStringSanitizer {
    /**
     * Sanitizes a string that would be wrapped in {@link quote}
     * @param str The string to be sanitized
     * @param quote The quote that wraps the string, defaults to {@link StringQuoteType.Double}
     */
    sanitize(str: string, quote?: StringQuoteType): string;
}

declare enum OverpassErrorType {
    QueryTimeout = 0,
    NetworkError = 1,
    TooManyRequests = 2,
    DuplicateQuery = 3,
    QueryError = 4,
    ServerError = 5,
    UnknownError = 6,
    MemoryExhaustionError = 7,
    NoAtticData = 8,
    ParameterError = 9
}
interface ErrorOptions {
    cause?: unknown;
}
declare class OverpassError extends Error {
    readonly type: OverpassErrorType;
    constructor(type: OverpassErrorType, message?: string, options?: ErrorOptions);
}
declare class OverpassParameterError extends OverpassError {
    constructor(message?: string, options?: ErrorOptions);
}
declare class OverpassApiError extends OverpassError {
    readonly httpCode: number;
    readonly url: URL;
    constructor(type: OverpassErrorType, httpCode: number, url: URL, message?: string, options?: ErrorOptions);
}
declare class OverpassQueryError extends OverpassApiError {
    readonly query: string;
    constructor(type: OverpassErrorType, httpCode: number, url: URL, query: string, message?: string, options?: ErrorOptions);
}
declare class OverpassRemarkError extends OverpassError {
    readonly query: string;
    readonly remarks: string[];
    constructor(type: OverpassErrorType, query: string, remarks: string[], options?: ErrorOptions);
}

interface OverpassStatusValidator {
    validate(response: HttpResponse): OverpassStatus;
}

interface OverpassQueryValidator {
    validate<S extends OverpassSettings, O extends OverpassOutputOptions>(query: string, httpResponse: HttpResponse, format?: OverpassFormat): OverpassApiOutput<S, O>;
}

declare class OverpassApiObjectImp implements OverpassApiObject {
    private readonly adapter;
    private readonly interpreterUrl;
    private readonly statusUrl;
    private readonly queryValidator;
    private readonly statusValidator;
    private readonly compileUtils;
    private readonly tagBuilder;
    private readonly evaluatorItemBuilder;
    static readonly MAIN_INSTANCE: URL;
    constructor(adapter: RequestAdapter, interpreterUrl: URL, statusUrl: URL, queryValidator: OverpassQueryValidator, statusValidator: OverpassStatusValidator, compileUtils: CompileUtils, tagBuilder: OverpassTagFilterBuilder, evaluatorItemBuilder: OverpassItemEvaluatorBuilder);
    static BuildDeprecated: (adapter: RequestAdapter, interpreterUrlInput?: string | URL, statusUrlInput?: string | URL) => OverpassApiObjectImp;
    static InterpreterUrlFromDeprecated: (interpreterUrlInput?: string | URL) => URL;
    static StatusUrlFromDeprecated: (interpreterUrl: URL, statusUrl?: string | URL) => URL;
    static StatusUrlFromInterpreterUrlDeprecated: (interpreterUrl: URL) => URL;
    /** @deprecated since 1.8.1, will be removed on 2.x.x, use root function {@link BuildOverpassApi} */
    static Build(adapter: RequestAdapter, interpreterUrlInput?: string | URL, statusUrlInput?: string | URL): OverpassApiObjectImp;
    /** @deprecated since 1.8.1, will be removed on 2.x.x, use root function {@link InterpreterUrlFrom} */
    static InterpreterUrlFrom(interpreterUrlInput?: string | URL): URL;
    /** @deprecated since 1.8.1, will be removed on 2.x.x, use root function {@link StatusUrlFrom} */
    static StatusUrlFrom(interpreterUrl: URL, statusUrl?: string | URL): URL;
    /** @deprecated since 1.8.1, will be removed on 2.x.x, use root function {@link StatusUrlFromInterpreterUrl} */
    static StatusUrlFromInterpreterUrl(interpreterUrl: URL): URL;
    get __adapter__(): RequestAdapter;
    private compileParts;
    buildQuery(statementBuilder: (state: OverpassState) => OverpassStatement[] | OverpassStatement, options?: OverpassOutputOptions, settings?: OverpassSettings): string;
    private doRequest;
    exec<S extends OverpassSettings, O extends OverpassOutputOptions>(settings: S, statementBuilder: (state: OverpassState) => OverpassStatement[] | OverpassStatement, options?: O | undefined): Promise<OverpassApiOutput<S, O>>;
    execJson<S extends OverpassSettingsNoFormat, O extends OverpassOutputOptions>(statementBuilder: (state: OverpassState) => OverpassStatement[] | OverpassStatement, options?: O | undefined, settings?: S | undefined): Promise<OverpassApiOutput<OverpassJsonSettings<S>, O>>;
    private getUnknownFormat;
    execQuery(queryInput: string | CompileFunction): Promise<OverpassJsonOutput | string>;
    private static NormalizeOutput;
    createFunction<Args extends AnyParamValue[], S extends OverpassSettingsNoFormat, O extends OverpassOutputOptions>(argTypes: ArgTypes<Args>, statementBuilder: (state: OverpassState, ...args: CreateFunctionArgs<Args>) => OverpassStatement[] | OverpassStatement, options?: O, settings?: S): OverpassApiFunction<Args, S, O>;
    createFunction<Args extends AnyParamValue[], S extends OverpassSettingsNoFormat, O extends OverpassOutputOptions>(argTypes: ArgTypes<Args>, statementBuilder: (state: OverpassState, ...args: CreateFunctionArgs<Args>) => CreateFunctionContext<S, O>): OverpassApiFunction<Args, S, O>;
    status(): Promise<OverpassStatus>;
}

interface OverpassApiObjectOptions {
    readonly interpreterUrl?: string | URL;
    readonly statusUrl?: string | URL;
    readonly sanitization?: true | false | OverpassStringSanitizer;
}

declare function DefaultOverpassApi(options?: OverpassApiObjectOptions): OverpassApiObject;
/** @deprecated since 1.8.1, will be removed on 2.x.x, use {@link FetchOverpassApi} with {@link OverpassApiObjectOptions}*/
declare function DefaultOverpassApi(interpreterUrl?: string | URL, statusUrl?: string | URL): OverpassApiObject;

declare function FetchOverpassApi(options?: OverpassApiObjectOptions): OverpassApiObject;
/** @deprecated since 1.8.1, will be removed on 2.x.x, use {@link FetchOverpassApi} with {@link OverpassApiObjectOptions}*/
declare function FetchOverpassApi(interpreterUrl?: string | URL, statusUrl?: string | URL): OverpassApiObject;
/** @deprecated since 1.8.1, will be removed on 2.x.x, use {@link FetchOverpassApi} with {@link OverpassApiObjectOptions}*/
declare function FetchOverpassApi(optionsOrUrl?: OverpassApiObjectOptions | string | URL, statusUrl?: string | URL): OverpassApiObject;

declare function HttpOverpassApi(options?: OverpassApiObjectOptions): OverpassApiObject;
/** @deprecated since 1.8.1, will be removed on 2.x.x, use {@link HttpOverpassApi} with {@link OverpassApiObjectOptions}*/
declare function HttpOverpassApi(interpreterUrl?: string | URL, statusUrl?: string | URL): OverpassApiObject;
/** @deprecated since 1.8.1, will be removed on 2.x.x, use {@link HttpOverpassApi} with {@link OverpassApiObjectOptions}*/
declare function HttpOverpassApi(optionsOrUrl?: OverpassApiObjectOptions | string | URL, statusUrl?: string | URL): OverpassApiObject;

declare function XMLOverpassApi(options?: OverpassApiObjectOptions): OverpassApiObject;
/** @deprecated since 1.8.1, will be removed on 2.x.x, use {@link XMLOverpassApi} with {@link OverpassApiObjectOptions}*/
declare function XMLOverpassApi(interpreterUrl?: string | URL, statusUrl?: string | URL): OverpassApiObject;
/** @deprecated since 1.8.1, will be removed on 2.x.x, use {@link XMLOverpassApi} with {@link OverpassApiObjectOptions}*/
declare function XMLOverpassApi(optionsOrUrl?: OverpassApiObjectOptions | string | URL, statusUrl?: string | URL): OverpassApiObject;

export { type ActualEnumParamType, type ActualParamType, type AndChainableOverpassStatement, type AnyCSVField, type AnyOverpassElement, type AnyOverpassQueryTarget, type AnyOverpassTagFilter, type AnyParamValue, type ArgTypes, CSVField, type ChainableOverpassStatement, type CompilableItem, type CompileFunction, type CompileUtils, type CompiledItem, type CompiledOverpassBoundingBox, type CompiledOverpassGeoPos, type ComposableOverpassStatement, type CreateFunctionArgs, type CreateFunctionContext, DefaultOverpassApi, type EnumParamType, FetchOverpassApi, HttpMethod, HttpOverpassApi, type HttpRequest, type HttpResponse, OverpasComparissonOperator, type OverpassAnyString, OverpassApiError, type OverpassApiFunction, type OverpassApiObject, OverpassApiObjectImp, type OverpassApiOutput, type OverpassArea, OverpassArithmeticOperator, type OverpassBasicElementType, type OverpassBooleanEvaluator, type OverpassBooleanEvaluatorThen, type OverpassBoundingBox, type OverpassCSVFormatSettings, type OverpassCSVSettings, type OverpassChainableTargetableState, type OverpassCount, type OverpassDateEvaluator, type OverpassElement, type OverpassElementBounds, type OverpassElementType, type OverpassEnum, OverpassError, OverpassErrorType, type OverpassEvaluator, type OverpassEvaluatorBuilder, type OverpassEvaluatorExpression, type OverpassEvaluatorNode, type OverpassExpression, OverpassFormat, type OverpassGeoPos, type OverpassItemEvaluatorBuilder, type OverpassItemEvaluatorCountBuilder, type OverpassJsonOutput, type OverpassJsonSettings, type OverpassMagnitudeEvaluator, type OverpassNode, type OverpassNodeString, type OverpassNumberEvaluator, type OverpassOsmElement, OverpassOutputGeoInfo, type OverpassOutputOptions, OverpassOutputVerbosity, OverpassParameterError, type OverpassPositionLiteralExpression, OverpassQueryError, type OverpassQueryRegExpTagFilterTuple, type OverpassQueryTagFilterFunction, type OverpassQueryTagFilterTuple, type OverpassQueryTagFilters, type OverpassQueryTagFitlerObject, OverpassQueryTarget, type OverpassQueryTargetExpression, type OverpassQueryTargetString, type OverpassQueryValidator, type OverpassRecurseFilterStatement, OverpassRecurseStmType, type OverpassRelation, type OverpassRelationMember, type OverpassRelationString, OverpassRemarkError, type OverpassRunningQuery, type OverpassSettings, type OverpassSettingsBase, type OverpassSettingsNoFormat, OverpassSortOrder, type OverpassState, type OverpassStateMethods, type OverpassStatement, type OverpassStatementTarget, type OverpassStatus, type OverpassStatusValidator, type OverpassStringEvaluator, type OverpassStringSanitizer, type OverpassTagFilter, type OverpassTagFilterBuilder, type OverpassTagFilterHelper, type OverpassTargetMap, type OverpassTargetMapState, type OverpassTargetState, type OverpassTargetStateStatement, type OverpassTargetableState, type OverpassTimeline, type OverpassWay, type OverpassWayString, ParamItem, ParamType, type RecurseFromPrimitiveType, type RecurseToPrimitiveType, type RequestAdapter, StringQuoteType, type ValueTypeFromParam, XMLOverpassApi };
